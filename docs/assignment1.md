# Assignment 1
Maximum number of words for this document: 2500
## Introduction
Author: Taylor Doughty

&emsp;  In this course, we have designed a text-based adventure game system and an interactive story demo. As for the system itself, we have implemented numerous game features along with satisfying quality requirements. As a main idea for developing our system, we’ve focused on dividing implementation of the features from the game logic. In doing so, the features of the game can act as a “blueprint” for game developers to create interactive stories of their own. Therefore, the users of this project will be not only players, but game developers. However, for demonstration purposes, an interactive story demo was implemented titled Meow Manor, to showcase how our system performs, and give ideas as to how the system could be used as a basis for other interactive stories.

&emsp;  The main idea of our game is that it is a system in which can be implemented with interactive stories. For the gameplay, the player will have the ability to interact with their environment and move between locations in order to progress through the game. These interactions refer to, broadly speaking, the proper use of non-static items, static items, static items along with non-static items, interactions with NPC, and defeating enemies. Upon the completion of valid interactions, the player will be rewarded with a “puzzle point.” To elaborate, in the context of this system, a “puzzle” refers to a successful combination of particular actions and items as done by the player. For example, if a player uses item x on item y as the system had intended, they have completed a puzzle and will thus be awarded a puzzle point. Once a certain amount of these points are achieved, the player moves onto the next level. Once the player has reached the max amount of levels, they have won the game, and thus the game ends. The amount of puzzles per level, and the amount of levels in each story is up for the interactive story writer to decide. If a player reaches 0 health points, then the player “loses” the game, in which they must resume the go back to the title screen to either load from the previous save or start a new save file.

&emsp; In order to make the gameplay dynamic and fun for the player, we have implemented  core features and bonus features, to make a combined amount of 43 features. Because there are so many and space is limited, not all of the features will be mentioned here explicitly, however they can be seen in detail further in the document. First, the core features will be described, followed by another paragraph in which a few bonus features will be mentioned

&emsp; The first core feature is the ability for players to interact with the interactive story by typing instructions (F1). The syntax differs slightly depending on the exact feature of the game, but the interactions achieved by typing instructions include actions such as moving to a location, saving or loading the game, interacting with NPCs, interacting with items, etc. The next core feature is puzzles (F2), which are key components of how the game works. What a puzzle refers to in this game, is any valid combination of item interaction. For example, if a player of Meow Manor needs to give a can of tuna to another cat, successful completion of this command will result in a gained puzzle point. How puzzles relate to the system, is that once a certain amount of them are achieved, the player progresses to the next level. Each interactive story may have a different amount of puzzles required to progress to another level. The amount of puzzle points gained will be private to the player, as an incentive to immerse themself in the interactive stories rather than just trying to win the game. The next core feature is levels (F3). The amount of levels for each story depends on the story itself, but there is always at least one. Each level consists of a certain amount of puzzle points needing to be achieved. Once a player progresses to a new level, they will be teleported to this starting location in a new location within the game. Like the puzzles, the level of the player will also be private as to not distract from the story line. Next core feature is locations (F4). Locations are places within the game that consist of items and NPCs, and have titles as well, for example such as “the garden,” or “the kitchen,” depending on the storyline. Locations are highly related to levels in that levels have one or many locations in which puzzle points can be achieved. Players will be able to move between locations as the story permits and if its allowed by their current level. For example, a player may move between a “living room” location and a “dining room” location if both are available for their current level and the storyline has the rooms “connected.” Teleporting only occurs upon the progression of a new level, and it is not done voluntarily by the player as a command but rather by the system. As mentioned before, there are items, which brings us to the fifth core feature (F5). Items are necessary to win the game, but it is possible that there are items that do not specifically have to be used. For example, if one level consists of 7 puzzle points, a player may advance to the next level having not interacted with particular items, but just enough to achieve 7 points. This all depends on the particular storylines themselves. Items have characteristics, such as the ability to be consumed, be put in an inventory, or not be put in an inventory for example. Each item also has a description which can be printed upon the use of the “examine” command by the player (see F23), as well as a description which is printed upon the successful action of that item. Players of the stories will also have inventories (F6). Players will be able to pick up and store particular items within an inventory in which they can use at a later time. Other important core features of the system include the ability to explicitly save progress (F14) and to load a game from a previous save (F15), thus allowing players to continue playing at a later time. 

&emsp; Now, a few bonus features will be described. A significant bonus feature is NPCs (F7). For each interactive story, there is to be at least one non-playable character in which has a name, description, and interaction possibilities. There are two types of NPCs: friendly and enemy NPCs. As for friendly NPCs, they have a list of traits which will enable certain interactions, such as the ability to give them an item. As for enemies, they do not have traits, and the only interaction is combat in which is automatically sequenced when a player enters a location in which an enemy is present. This leads to another bonus feature, combat (F8), in which players battle enemy NPCs. This battling goes on until either the enemy or the player is defeated, the latter in which means the player must start a new game or load their previous save at the title screen. A player can become defeated when their health points (F9) reach 0, which is another bonus feature. Health points can be lost during combat or when their hunger points (see: F12) reach a certain detrimental level. Concerning how players can interact with items and friendly NPCs, there are numerous ways, such as consuming them (F25), smelling them (F26), listening to them (F17), and reading them (F33) for example. These, along with the others as described in Functional Features, award puzzle points upon valid actioning and each interaction with each item prints a description detailing the effect that action had. For example, if a player consumes a cup of coffee, the string description may say something like “That was refreshing. I feel energized and less hungry,” to add storyline elements as well as give information concerning the effect the action had on the player itself or the progression of the storyline.

&emsp;  This has been a brief introduction into the main idea of the system, and the interactive stories that may be implemented within it. We have written the demo Meow Manor which is to showcase the features of the system and how interactive stories may function. Some core features as well as some bonus features were described, but due to the lack of space, some may only be referred to below in the Functional Features section.Speaking of the features and design of the system, we were influenced by the game Zork. Primarily, the idea is that the protagonist adventures and explores a world, in which they can interact with objects and the world around them. Because the project is to be a “minimal clone” of the game, we also designed the features of the gameplay taking inspiration from the game. As for the display appearance of the game, we have taken inspiration from a tutorial.


Inspiration:

[Zork](https://en.wikipedia.org/wiki/Zork)

[How to Make Text Adventure Game with GUI in Java](https://www.youtube.com/watch?v=G5yr4sekAI0)


## Features
Authors: Ece Doganer

### Functional features


| ID  | Short name  | Description  |
|---|---|---|
| F1 | Instructions | User can interact with the interactive story through typing instructions. These instructions have the following possible syntax:<br/><br/> core:<br/>`[command]`<br/> `[command] + [direction]`<br/>  `[command] + [item]`<br/><br/>bonus:<br/>  `[command] + [NPC]`<br/> `[command] + [item] + [item]`<br/> `[command] + [item] + [NPC]`<br/><br/> Available item, NPC, and direction instructions, depend on the story.<br/><br/>  All possible instructions for `[direction]` are as follows:<br/> `north, east, south, west, northeast, northwest, southeast, southwest`.<br><br> Available `[commands]` are as follows:<br> core:<br>`save, load, pickup, move, use`<br> bonus:<br> `quit, talk, drop, give, consume, open, close, push, pull, unlock, attack, break, cut, examine, look, directions, inventory, help, read, listen, smell, back, menu`<br><br> Bonus syntax and their functionality are as follows: <br>`[item]` ---> If possible, picks up item if it is in player's current location, or, consumes item if it is in player's inventory <br> `[NPC]` ---> If possible, talks with NPC<br> `[direction]` ---> If possible, moves to the location in this direction<br/><br/> The functionality of the commands will be hardcoded. In order to make the game customizable, instructions (excluding save, load, quit, menu, help, back, drop, inventory, directions) will print interaction text. This instruction text is customizable for a game creator.<br/><br/> The validity of an instruction, depends on the story, and the current location of the player. If an instruction is invalid, an error message will be shown (see instruction validation). <br>--- |
| F2 | Puzzles | ---<br>In order to win the game, a player interacts with the interactive story, playing through the story from start till end. In this story, there might be one or more levels, with each their own amount of puzzles. A puzzle is ambiguously described here. Interaction with an item can or can't give puzzle points, depending on the type of interaction, and the intention of the game creator with this item. <br><br>The interactions containing instructions with the commands 'use', 'give', 'open', 'close', 'push', 'pull', 'cut', could solve puzzles. The validity of these interactions, depends on the story (see Instructions). If the instruction is valid, performing these interactions will award a puzzle point. <br><br>The amount of the puzzle points per level, depends on the interactive story, and will be given by the game creator. After this amount of puzzles is complete, player can progress to the next level, or will receive a message indicating player has won the game. <br><br>Additionally: These puzzle points will not be known to the player, and the rationale here is to immerse player in the story instead of focusing on a score. <br>--- |
| F3 | Levels | ---<br>Each interactive story has one or many levels. Each level has its own amount of puzzle points, which require from the player to perform interactions. After every instruction, a check is run to see if the amount of puzzle points required to finish a level, has been reached. After performing the amount of interactions required, the system will teleport the player to the next level and its starting location.<br><br> Levels have a starting point for the player, a location. Levels have one or multiple locations. When entering a level, a description of the level is printed. These levels, will never be known to the player, in order to immerse in the story. <br><br>Game creators could see levels as a big event within the storyline, where a big part of the story can be described. <br>--- |
| F4 | Locations | ---<br>Levels have one or many locations. Locations can have items and NPCs (see Items, NPCs). <br><br> If we would represent locations as nodes in a graph, the tree graph would have vertices with a maximum of 8 connected edges (north, east, south, west, northeast, northwest, southeast, southwest). Two vertices would be connected by exactly one path.<br><br> At the creation phase of a story, these locations will be connected with each other. These locations will be accessible for the player to move to them, at any time, as long as there is a connection from player's current location to the desired location. Core: moving will commence through `move [direction]` instruction. The direction, for example, north, will lead to the location saved for this direction, for the current location. <br><br> Each location will be unique, and will have a description and unique name. Every time a player visits a new location, its description will be printed automatically. When the player instructs `look`, the description of the location shall be printed (again), as well as a list of the names of items and NPCs within this location. <br>--- |
| F5 | Items | ---<br>For every interactive story, there will be a number of items. Some of these items are necessary to win the game. There is no cap on the maximum amount of items. The minimum is at least one item, in order to have an interactive story with only one puzzle.<br><br> Items have characteristics, which will be checked, in order to do certain instruction combinations. For example:<br> if apple is a consumable, it will be possible to instruct 'consume apple' without an error message. Instructing it will print the interaction text of consuming this apple, on the screen. <br><br>The core list of traits of an item are that it can or can't be picked up, and used. <br><br>The full list of traits of an item are extensive, and will be treated in other features. <br><br> When player is in a location with an item, the instruction `examine [item]` can be issued. The description of this item is then printed. The same instruction can also be issued for items in player's inventory. <br>--- | 
| F6 | Inventory | ---<br>A core feature is for the player to have an inventory. The player will have the option of picking up items, storing them in inventory and using them in the location that the player is currently in. The inventory can hold an indefinite amount of items. A bonus is to be able to instruct `inventory`, which gives an overview of the currently held items, if any. <br>--- |
| F7 | Bonus: NPCs | ---<br>For every interactive story, there might exist some Non-Playable Characters. The minimum is zero, the maximum is not capped. They are unique, with unique names, and should have unique descriptions and interaction possibilities. All NPC related functionality of the system, is bonus. <br><br>An important distinction is that there are two types of NPCs: friendly, and enemy.<br><br> Enemy NPCs do not have traits. When a location that the user enters contains an enemy NPC, a battle sequence will immediately commence. Player will need to battle this NPC. See feature Combat. <br><br> A friendly NPC has a list of traits, which can be set to true and false. These traits, which we further discuss in other features, will enable certain interactions with this NPC.<br><br> When the player is in a location with a friendly NPC, `examine [NPC]` can be instructed. This will print the description of the NPC. <br>--- |
| F8 | Bonus: Combat Mode | ---<br> When there is an enemy NPC in the location that player enters, and roll dice decides that the enemy will attack player, a battle sequence starts. In this primitive battle sequence, player can only attack the enemy, and be attacked. Player always attacks first, and deals damage to the enemy in the amount of strength points the player has, lowering enemy's health points. Just like player, enemy also deals damage, equal to the amount of his strength points, to the health points of player. Within this course, we do not plan on expanding the available commands in combat mode. <br><br>This battle continues until player defeats the opponent, or dies trying. In both cases, the battle sequence comes to an end. <br><br>When player dies, the only options left to do are to start a new story, load a previously saved story, or to quit game completely.<br><br>When player is victorious, first of all, the combat mode is over and the story can continue. So a battle can be described as an obstacle for the continuation of the story. Secondly, winning a battle increases the experience points of the player. When player gathers enough experience point he levels up which results in increase in current health, maximum health and damage. This helps in the way that a player will be able to survive battle with more difficult foes later on. <br>--- |
| F9 | Bonus: Health Points | ---<br> Health points is a number which indicates health of the player. The total and current amount of health is customizable by the game creator. <br><br> Health can be lost due to attack by an enemy NPC or through starvation (when hunger level reaches zero). When hunger is at a customizable amount which we term 'starvation mode', a customizable amount of health points will be deduced from the total health points. Health can be restored by consuming food (see Hunger feature). The amount of health restored by consuming an item, is customizable by the game creator. Default health points added per consumption is 10.<br><br> If the player has zero health points, the game is over. In this case, a new story can be started, a previously saved story can be loaded, or the game can be quit.<br><br> When player levels up, the total of health points will be increased, as well as the current health points. <br><br>Health is a bonus feature, that will be implemented only after finishing GUI feature. Thus, indication of health will be visual, through a bar that is updated when health increases or decreases. <br>---|
| F10 | Bonus: Strength Points | ---<br>In combat mode, the damage done is the number of strength points a player has. This number is customizable by the game creator. Enemy also has customizable strength points. Both inflict the amount of their strength points, to each others health points, sequentially. If an enemy is too strong for the player to handle, player can only tell by entering combat. In this case, player needs to load story from his last saved slot or from the auto-save slot. Player can then hopefully avoid this location, thus avoiding the battle. Other battles can be started, to that player's strength improves. Or, player needs to find a way to solve the story without entering the battle. This is up to the game creator. <br>---  |
| F11 | Bonus: Experience Points and Player Level | ---<br> Issuing a fully valid instruction for certain instructions, will grant the player experience points. Also through battle, player can be rewarded experience points. With a total amount of experience points, which is customizable for the game creator, the player will level up. Through leveling up, strength points will be gained, in order to battle tougher enemies. <br>--- |
| F12 | Bonus: Hunger | ---<br> Hunger is a number that determines whether a character is starving or not. The default is that at fifty hunger points, a customizable amount of health points will be reduced. <br>--- |
| F13 | Input Validation | ---<br>Input will be checked for validity, which we do in two steps: input- and instruction validity.<br><br>All input issued will print text. The distinction here is input and instruction: Input will firstly be parsed into 'words'. These words will be checked for validity. A word is valid if one of the next terms apply: - the word is equal to one of the commands in the command list. - the word is equal to one of the directions in the directions list. - the player's current location's NPC list has an NPC with the name, equal to the word. - the player's current location's item list has an item with the name, equal to the word. Or, the inventory's item list has an item with the name, equal to the word. When these terms apply, an input is valid. From here on, instruction validation can commence. If these terms do not apply, an error message will be given, stating that the system did not understand the input. Additional: The reason why input is checked immediately within inventory or current location of the player, is because it is faster. The alternative, checking through all existing items within a game, is time consuming and unnecessary. <br><br> After input is validated, instructions will be validated as follows: items and NPCs have certain traits. For example, item apple can be picked up, and eaten. Depending on these traits, certain commands become valid: 'pickup apple' and 'consume apple'. Other commands, like 'cut apple', are invalid, and will result in an error message stating this item cannot be cut. If a valid instruction is given, the action will be performed. Indication of this action having been performed, is that a customizable interaction text will be printed. <br><br> After input and instruction are validated, the instruction will be handled. The instructions containing 'use, give, open, close, push, pull, cut', will give a puzzle point. Other instructions help player progress the story, help battle, or help still player's hunger. <br><br> All valid instructions will print an interaction text, which is customizable by the game creator. Certain instructions change the stats of the player.(see Hunger, EXP) ... <br>--- |
| F14 | Explicit Save Game | ---<br>Player shall have the option to save current progress tied to the story she/he is playing at the moment. This includes all necessary information needed to resume the game at a later point after the game executable is opened again. To explicitly save, player needs to be outside of the combat mode, and has to issue `save`. <br>--- |
| F15 | Load Game | ---<br>Player shall have the option to load a previously saved game. Player can only load outside of combat mode. When issuing `load`, player will be presented with the previously saved files that he can select. There is also an option to go back without loading.<br>--- |
| F16 | Bonus: Automatic Save Game | ---<br>After five inputs, irrespectively of their validity, the story will be saved in a special save slot, called Auto Save. Player can load the game from this slot. Additionally, auto-save feature is not available in combat-mode. <br>--- |
| F17 | Bonus: Game Creator Mode | ---<br>This is a very big bonus feature. The user of our game, will be able to create a story: user will be able to create levels with names and descriptions and amount of puzzle points, locations with names and descriptions with their own sets of connecting locations, items, friendly and enemy NPCs. Those entities will have a name, description, and will have a set of traits, resulting in the instructions available with that entity. All these instructions will require an interaction text as well, for when the user has issued them. We will have a questionnaire for the game creator, which will ask all this information sequentially. Error messages will be shown if names contain spaces. Error messages will be shown for empty inputs. Game creator cannot quit the process of creating a game, and cannot make adjustments. Game creator will be prompted to write in top down motion, starting with one level, its locations, those locations' items and NPCs and their traits. Then, another level can be entered, or the game creator mode can be finished. This story will then be saved in one of the save slots available. <br>--- |
| F18 | Bonus: Graphical User Interface | ---<br>This bonus feature will have 4 major scenes:<br> Scene one is the welcoming scene, where player can click buttons to: start a new game, load a saved game, or quit.<br><br>The second scene is entered when player picks the new game button. In this scene, previously created games can be selected. If create game feature is implemented, it also be able to be selected, here. We have a button to go back.<br><br> A third scene, is when the player would have picked 'load game' instead of 'new game'. Here, we see two save slots, one slot for auto-save and another for explicit save. These slots will be used to indicate a saved game, which can be selected. <br><br>The final scene, is the adventure scene. Both selecting a new game, and loading a previously saved game, will lead to the adventure scene. In this scene, the player's health points, hunger points, and experience points will be represented in bars with numbers inside them. Also, the level of the player will be represented next to them. All these elements will be grouped together. Another elements in the GUI will be the text box, where printing story text and receiving errors will happen. Finally, GUI will contain a text field element where input may be entered. <br>--- |
| F19 | Bonus: Backtracking | ---<br>Player's visited locations, is saved in a list. Every time Player instructs `back`, the player will be teleported to the previous location visited. If list is empty, meaning player has traced his steps back and returned to the starting position, then, when issuing `back` will give an error. <br>--- |
| F20 |  Movement | ---<br>Player can move between locations that are interconnected. this can be done by issuing `move [direction] `, or simply `[direction]`. Bonus syntax is that `move` can be exchanged by `run, go, walk`. <br>---|
| F21 | Picking up Items | ---<br> If there are items in the current location of the player, then the player can try to pick up those items. If the item player wishes to pick up has the trait that it can be picked up, then the item will be deleted from the list of the current location, and will be copied into the list of inventory. A customizable interaction text for this specific item will be printed, which game creator can use as indication of the instruction's success but also for the story progression. Also, the item's trait pickup-able will become false, and trait drop-able will become true. <br><br> Items can be picked up by issuing `pickup [item]`. Bonus syntax is to `pick [item]`, where 'up' will be ignored. Also, just `[item]` could be used. If item is in the current location of the player, and has the trait that it can be picked up, it will be picked up.<br>--- |
| F22 | Bonus: Dropping Items | An item will have the drop-able trait after it is picked up. We can then, drop this item. If item has the trait that it is break-able, then it will break when dropping. <br>---   |
| F23 | Bonus: Examining Items and NPCs | If an item or NPC is in the current location of the player, the player can examine it, through issuing `examine [item]` or `examine [NPC]`. This instruction will print the description of the item or NPC. Also items in the inventory can be examined. Examining can happen as often as the player would like to. |
| F24 | Bonus: Look around in the Location |---<br> When player issues `look`, a description should be printed of the current location. Next to this, the items and NPCs in this location will be listed by their name.  <br>---|
| F25 | Bonus: Consume Items or NPCs |---<br> Items or NPCs can have the trait that they can be consumed. When issuing `consume [item]` or `consume [npc]`, player can consume said entity for health and hunger points. The default health points gained is 10, and the default for hunger is 15. The game creator can customize this. Bonus syntax is `eat` and `drink`, though the issue that for example an apple can be drank, we will not solve. Interaction text will be printed.  <br>---|
| F26 | Bonus: Smell location, item, npc|---<br> Issuing `smell` will smell player's current location. For `smell [item]`: if item has the trait that it can be smelled, then it will become valid to issue, and will result in the printing of the interaction for smelling, of said item. For `smell [npc]`, the same applies. <br>---|
| F27 | Bonus: Listen to location, item, npc |---<br>Exactly the same as smell instruction, applies to the `listen`, `listen [item]` and `listen [npc]` instructions. Interaction text will be printed. <br>---|
| F28 | Bonus: Talk to item, npc |---<br>The same as the smell instruction but excluding location, applies to talking: `talk to [item]` and `talk to [npc]`. Interaction text will be printed. <br>---|
| F29 | Bonus: Push item, npc |---<br>The same as the talk instruction applies to pushing: `push [item]` and `push [npc]`. By issuing this instruction, player receives puzzle points and experience points. Interaction text will be printed.  <br>---|
| F30 | Bonus: Pull to item, npc |---<br>Exactly same as the push instruction applies to pulling: `pull [item]` and `pull [npc]`. Also, puzzle points and experience points are awarded for pulling. Interaction text will be printed.  <br>---|
| F31 | Bonus: Open item, npc |---<br>Exactly same as the pull instruction applies to opening: `open [item]` and `open [npc]`. Also, puzzle points and experience points are awarded for opening. Additionally, some items need other items to open, just like npcs. `open [item] with [item]` or `open [npc] with [item]` is applicable here. Interaction text will be printed. <br>---|
| F32 | Bonus: Close item, npc |---<br>Exactly same as the pull instruction applies to closing: `close [item]` and `close [npc]`. Also, puzzle points and experience points are awarded for closing. Interaction text will be printed. <br>---|
| F33 | Bonus: Read item |---<br> If item in current location or in inventory, has the trait that it is readable, then `read [item]` instruction will be valid. When issuing it, the interaction text for reading this item, will be printed.<br>---|
| F34 | Bonus: Quit Game |---<br>At any time except in combat mode, player can issue `quit`. The game will stop expecting input, and finish running, closing the window. An additional bonus word for this is `exit`. This feature will not save or check if player really wanted to quit. <br>---|
| F35 | Bonus: Help |---<br> At any time except in combat mode, player can issue `help`. This will print a list of all the possible syntax combinations. <br>---|
| F36 | Bonus: GUI menu instruction |---<br> At any time except in combat mode, player can issue `menu`. This will change the adventure scene into the welcome scene. There will be no back button. <br>---|
| F37 | Bonus: Attack item, NPC |---<br> At any time except in combat mode, player can try to issue `attack [item]` or `attack [npc]` for the items and npcs player's current location. If these items and npcs's have the trait that they can be attacked, then attacking can commence. If an item is attacked, its interaction description for attacking is printed. Furthermore, if item has the trait that it can be broken, then item will break. If NPC is attacked, a battle sequence will commence. See Combat feature. <br>---|
| F38 | Bonus: Unlock item |---<br>At any time except in combat mode, player can try to issue `unlock [item] with [item]`. If item1 will have the trait that it can be unlocked, and will have item2 saved as its unlocking item, then item1 will be unlocked. Puzzle points are given for unlocking. Also interaction text will be printed. <br>---|
| F39 | Bonus: <br>Use item,<br> Use item on item,<br> Use item on NPC |---<br> If an item has the trait that it can be used, then `use [item]` can be issued. If item1 has the trait that it can be used on item2, and item2 has item1 as the item it requires to be used by then `use [item] on [item]` is valid. If NPC requires item to be used on it, then `use [item] on [npc]` is valid. Using instructions grant puzzle points.   <br>---|
| F40 | Bonus: Break item |---<br> An item with the breaking trait, can be broken. This item might be able to be broken as is, or might require another item to break it: `break [item]`, and `break [item] with [item]`, respectively. For the latter, item to break needs to have the the item to help break, as its required item. Breaking an item prints interaction text, increases puzzle points and experience points, and also removes the item from inventory or current location of the player. <br>---|
| F41 | Bonus:<br>Cut item with item,<br> Cut NPC with item |---<br> If an item or npc has the trait that it can be cut, then they require a certain item to be cut with. if this is the right item in the instructions `cut [item] with [item]`, and `cut [npc] with [item]`, then these instructions are valid, and will print interaction text. Cutting gives puzzle points and experience.  <br>---|
| F42 | Bonus: Give item to NPC |---<br> If NPC has the trait that it requires an item, and requires the item in the issued instruction of `give [item] to [npc]`, then this instruction is valid, and will print the interaction text for giving, for this item. Also, puzzle points and experience will be given.<br>---|
| F43 | Bonus: Get directions |---<br>At any time except in combat mode, player can issue `directions`. A list of directions available to move to, from the current location, will be printed. <br>---|

### Quality requirements
Author: Ece Doganer

| ID | Short name | Quality attribute | Description | Rationale | Alternatives |
|---|---|---|---|---|---|
| QR1 | Extensible World | Maintainability, Reusability | System shall be extensible in terms of levels, rooms, and objects. | Adaptability: code is less complex, less reliant on storyline, more adaptable to different stories. | A system designed for one unique story-line. |
| QR2 | Instantaneous results | Responsiveness, Reliability | System shall respond to any action playerStats performs, within 1 second. | Expected from software experience: instant results. Also, requirement signals response time to user, thus indicating error. | Long waiting times in game. Coding without speed in mind, resulting in loading messages. |
| QR3 | Ready for input | Availability | System shall show full story when a game has entered, and every time an input is issued. | Users have their own speed of reading. User’s desire for system's readiness for input is connected to desire for immediate output. | Story-based text shown in increments, helping readers read along the intentions/pacing of story. Our system shall show story-text immediately, signaling input-readiness when screen is printed. If user intends to move north 12 steps, there is no delay. |
| QR7 | input correctness | Understandability, usability | If action is incorrect, user should understand. This can be in form of a message, or another signal, like showing a red border with GUI. |||
| QR8 | input latency | Input will be issued within 1 second. |||


### Java libraries
Author: Mateusz Belka

| Name (with link) | Description |
|---|---|
| [Gradle](https://gradle.org) | Our project, as well as the majority of projects in Java, make extensive use of libraries and frameworks. Thus, it is necessary to have a method of dependency management to allow developers to focus on designing the software itself and not manage the tools. Gradle provides such support, and therefore we use it to simplify the process of using pre-existing tools to aid our sophisticated design. There are several reasons why we have decided to use Gradle. First of all, high performance - this means a decrease of built time and an optimization of the work: running only necessary tasks, processing files that have changed and reusing the build of outputs with the same inputs. Secondly, since we are working in the Intellij IDEA, it is crucial for us and our workflow that the tool would support the IDE we are working with. It affects not only productivity and convenience but also time spent on working on certain parts of the code. Finally, as we have mentioned, dependency management. Dependency is a library that is used by a developer in the source code. Gradle allows for resolving this dependency by locating declared dependencies for performing a specific task at runtime. This way, it prevents certain libraries from leaking into the user's classpath and provides better-modelled and faster builds. |
| [Text-IO](https://github.com/beryx/text-io) | Users interact with their computers in widely different manners. Therefore, a part of them has very limited knowledge of the capabilities of their operating system. As such in order not to force users into launching our game from terminal, which many users may be unfamiliar with, our goal is provide an executable file that can be launched by just clicking on it. In a default situation attempting to do that would result in nothing happening as console input and output calls would be ignored without terminal being present. However, our intention is for our game to open in custom third-party swing terminal in scenarios where the game is not already being launched through one. Such terminal would naturally integrate with java.io.Console calls. |
| [JOpt Simple](https://github.com/jopt-simple/jopt-simple) | Our aim is to allow users to communicate with our system using natural language form. In order to achieve this, the users' input has to be parsed. We intend to utilize this library to maintain high-quality readable input parsing code which executes highly complicated tasks behind the scene. |
| [Java.time](https://github.comMenoDataTime4J) | A time library provides API for time, duration, instants and other timestamps. For the implementation of certain bonus features, it is important to have a time library. Starvation is a part of a hunger point feature. Starvation is a process during which a character is not consuming any goods for a certain period of time. Time library provides all the necessary attributes for the implementation of a starvation functional feature.|
| [FXGL](https://almasb.github.io/FXGL/) | As part of bonus feature we aim to implement a GUI widget toolkit instead of CLI due to it's more user-friendly interface as well as additional graphical functionality which hopefully will allow the user to have more enjoyable interface experience. Additionally, GUI provides a more stable executable version of the software since it's independent of users terminal. On top of that, default terminals tend to frighten novice computer users.a JavaFX is more preferential than similar libraries such as Lanterna due to more advanced and accessible documentation. Additionally, the proposed GUI libraries all provide the same functionality for our limited needs, and therefore it makes sense to select the one which is the most straightforward in implementation. The final version of GUI aims to represent a variation of terminal-based UI. |
