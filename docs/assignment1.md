# Assignment 1
Maximum number of words for this document: 2500
## Introduction
Author: Taylor Doughty

&emsp; We are designing a text-based adventure game. We will be implementing game features along with satisfying quality requirements. We have focused on dividing implementation of the features from the game logic. In doing so, the features of the game can act as a “blueprint” for game developers to create a game of their own. What this means, is that the game features are created separate from the storyline, therefore allowing game creators to input their own game logic.

&emsp; Our game is a single-player text adventure game. The player will have the ability to interact with their environment by moving rooms, picking up items to place in an inventory, using these items on static items, or interacting with static items alone. When these actions are successfully completed, the player will gain puzzle points which results in upgrading their level. Once the max number of levels has been achieved, the player wins the game! 

&emsp; To give a more detailed look at the exact features, they are the following: First feature is rooms (F1). How this works, is that the player will always belong to a room, as they are the overacting system of the adventure game. Players will be able to move to and from rooms depending on which directions are available (north, south, east, and west). Next is  movement (F2). The player will be able to move between the rooms, assuming that the rooms are interconnected and the storyline of the game allows them to do so. Concerning features available during the start-up of the game, they are the following three: The ability to create a new game (F3). When the game is first started-up, the user will have the option to start a new game, which allows the user to begin the first game save or to restart. Next is the ability to continue a saved game (F4). When the game is started-up, the user will also have the option to continue a previously started game, this way, they can carry-on with progress. We also have the implementation of items (F5), in which players will be informed about the items present in the room they are currently in. There are two types of items: PickupAbleItems, and NonPickupAbleItems. The former have the ability to be picked up, put in an inventory, and used on the latter. NonPickupAbleItems are also able to be actioned on their own. Finally, there are inventories (F6). The players will be able to store PickupAble items in their inventory, and use them in the room in which they are currently in on NonPickUpAbleItems. 

&emsp; There are also bonus features of the game that should be implemented. The first is HP, or health points (F7). This indicates the level of health of a character, which then determines the ability to function and perform tasks in the game, such as movement between rooms, and actioning items. HP can be lost due to attacks or starvation, and it can be restored by consuming food. The current HP value will be displayed during combat and every time a player changes rooms. This feature will allow the implementation of combat or hunger in a way that adds a sense of danger and risk within the game, therefore making the gameplay more entertaining. There is also combat (F8), in which a player will be able to battle an enemy until the player dies or the enemy is defeated. Along with this feature, players may have the ability to receive special weapons that can increase the probability of winning and the decrease that of losing.Next is experience points/XP (F9), which will be a numerical measure that indicates the experience of the character gained by successfully completing puzzle-solving elements of the game, and defeating enemies in combat. Next, levelling (F10) is a bonus feature of this game. To elaborate, players will be able to increase their “Level,” and this is done by completing puzzles and gaining puzzle points. These puzzle points are achieved by successfully actioning items. Once x amount of puzzles are completed, players will increase their level by one. In order for the player to win the game, they must complete all levels of the game.  Next comes hunger (F11) in which is a numerical measurement that indicates the character’s level of hunger. If fifty hunger points are reached, then it will result in a health point reduction. If the player reaches a certain number of health points, it may result in death and termination of the save file. Hunger points are reduced by consuming food. This feature coincides with the feature of HP, and will add dynamism to the game. Our next feature concerns puzzles (F12), in which game creators will be able to have as many puzzles as they would like per room. Next: winning and losing (F13). The idea is that in game creator mode, the creator can choose the amount of levels necessary to win the game. A player can lose by reaching a certain level of health, in which they must restart from either the beginning or the last save point. Players will have the ability to input commands to complete actions as well (F14).. The final bonus features, F15 and F16, involve saving the game. The former is explicit saving, in which players can save at any moment. The latter is automatic saving, in which the system automatically saves progress.

&emsp; For this project, we were influenced by the game Zork, in that the protagonist adventures and explores a world in which they can interact with objects and the world around them. Because the project is to be a “minimal clone” of the game, we also designed the features of the gameplay taking inspiration from the game. As for the display/appearance of the game, we have taken inspiration from a tutorial. 


***WORD COUNT: 965/1000***

Inspiration:

[Zork](https://en.wikipedia.org/wiki/Zork)

[How to Make Text Adventure Game with GUI in Java](https://www.youtube.com/watch?v=G5yr4sekAI0)

## Features
Authors: Valeriya Komarnitskaya, Mateusz Belka, Ece Doganer

### Functional features

Core Features:

| ID | Short name | Description | Rationale |
|---|---|---|---|
| F1 | Input Validation | Input validation is a feature that parses the inputted text and checks its validity. It searches in the input for direction, pickupable item name and static item name. As soon as the right combination has been found, it issues F1/F2/F3 and so on. This way, validator makes sure that the user can type different things, and the system will recognize what does a player want to do. | The feature increases the user-friendliness and allows a user to be more flexible in the input. |
| F2 | Commands| When a player enters the game, the first thing he/she can do is to input a command. There are four possible commands: move [in direction], pick up [pickupable item], use [pickupable item] on [static item] and action [static item]. -Move: allows a player to move in four possible directions: North, South, East, West. Depending on the configuration of the level, it might not be possible to access certain directions, depending on the room. Moreover, our input system is programmed such that a player does not have to type move. The direction is enough. -Pick up: allows a player to pick up an item, store it in inventory and use it on certain static items in the room in order to solve a puzzle. -Use: allows a player to use a picked up item from the room on the object in order to solve a puzzle. -Action:  | These four basic and yet necessary commands allow a user to get an experience of actually being in the room, collecting items and interacting with objects and items. This feature gives another level of depth to the game and makes the playing experience more enjoyable. The ability for a player to be able to type a direction with move keyword makes our game more user-friendly. |
| F3 | Room | Independently from the story, the player shall always belong to an individual room. Each story has its room configuration, which is a list connected of rooms in terms of how the player can move between them. | Division of locations, such as rooms allows for clear communication between structural elements of the game logic. Moreover, it allows user to get familiar with the core concepts of the game from which all other features branch out from. |
| F4 | Movement | The player shall have the choice to move freely between rooms that are interconnected and story-related. | The progression of the story is crucial to our game because it incentivizes user to continue playing. Ability to move between rooms allows a story creator to create a compelling and complex story that would otherwise not be achievable. |
| F5 | New Game | At the start of the game the user shall have the option to start a new game. That allows the user to begin the first game or restart his/her progress and begin anew. | Providing a user-friendly interface to start a new game is crucial. It also allows the user to restart the game conveniently. |
| F6 | Continue Game | At the start of the game, the user shall have the option to continue previously started, automatically saved game. That allows the user to carry on with already achieved progress. | We aim to support complex and unique stories; thus, they might not be completed during one session. Giving the user the ability to decide how long each session will create a positive user experience. |
| F7 | Items | The player shall be informed about the possible items present in the room he/she is currently in. The player shall have the option to pick up those items and place them in the inventory. | Puzzle-solving is a crucial part of progression in adventure games, so our goal is to implement an item system that is intuitive and fun to use by players. |
| F8 | Inventory | The player shall have the option of picking up items, storing them in inventory and using them in the room that the player is currently in. | We aim to provide users with high quality and intuitive inventory system that fully supports meaningful and challenging use of items to solve puzzles. |

Bonus Features 

| ID | Short name | Description | Rationale |
|---|---|---|---|
| F9 | HP/Health Points | Health points are indicating the level of health of a character and determine the ability to function and perform tasks in the game world. Health can be lost due to attack by an enemy or through starvation. Health can be restored by consuming food. A character might die and lose some progress after health reaches 0. In this case, a player either starts the game from the beginning or the last saved point. | Including health points in a game is essential in order to implement additional features such as combat or hunger properly. We believe that these features together add a sense of danger and create exciting challenges for a player. |
| F10 | Combat | A battle against an enemy until a player dies or defeats an opponent. After defeating, there is a chance of receiving items and losing health. A player might be able to receive weapons through items in rooms or as an award. The player can use those weapons in combat in order to hit harder, influence time spent on defeating an enemy and increase the probability of a win.| Combat system presents another level of depth to our Text Adventure Game. It allows the player to progress in a different manner in comparison to puzzle-solving. |
| F11 | Experience points/XP | Numerical measurement indicating the experience. The character starts with zero experience at the beginning of the game. Through successful puzzle-solving and defeating enemies, a character gains points. Experience points' collection leads to a level upgrade. | Implementing experience points in our game is essential in order to include an additional feature such as a level upgrade. This way, a player has a larger motivation to be active in the game upgrade the level. | 
| F12 | Levelling | The level is a numerical value indicating the level you are at. After getting a certain amount of experience points, it shall be possible to level up. | Adding levelling feature creates additional challenges and motivates a player to level up in the game. The feature makes our TAG more interesting and attractive to a player. | 
| F13 | Hunger level | A numerical measurement that determines whether a character is starving or not. Fifty hunger points lead to health points reduction. The longer the character was without consuming food, the more hunger points are gained. A hunger point reduction happens when a player feeds the character. | Hunger is an additional challenge for a player that makes the game experience more enjoyable.| 
| F14 | Structure of puzzles | Puzzle-solving is one of the main challenges in our game world. The main aim of a character is to solve every single puzzle in each room. We plan on having one puzzle per room; however, in the game creator mode, a player can choose as many puzzles as he/she wants per room. Puzzle in our game consists of picking up an item, finding the object to use the item on and using this item on. For example, if we see in the list of items key and the door, then to complete a puzzle, we need to use the key on the door. | Puzzle is an element of the game that makes a gameplay experience more enjoyable and the game interesting. A player has a larger motivation to keep playing to solve as many puzzles as possible.  |
| F15 | Winning and losing the game | In our implementation, a player wins a game when he/she solves all puzzles on each possible level. In the game creator mode, a player has an opportunity to create as many puzzles, rooms and levels as he/she wants. Thus, it can make the average winning time longer or shorter, depending on the number of puzzles. A player can lose a game by losing health. In this case, a player is offered to either start the game from the beginning or from the last saved point. | The ability to win or lose the game creates an additional level of depth in the gaming experience. It makes a player more motivated in playing and exploring the game. |
| F16 | Explicit Save | The player shall have the option to save current progress tied to the story she/he is playing at the moment. That includes all necessary information needed to resume the game at a later point after the game executable is opened again. | The ability to have an explicit button for saving tends to give players a relaxing feeling. From our personal experience, we've noticed people generally tend to not trust automatic save systems and depend on their action of saving the game. |
| F17 | Automatic Save| The system shall automatically save the player's progress. The player shall automatically have access to the latest saved information by selecting "Continue" at the start menu. | Novice users tend to go to another extreme of never saving their progress and afterwards regret not saving. To avoid such issues, we decided to implement autosave feature as part of our quality of life improvements for users. |
| F18 | Game Creator mode | A feature when a player can choose a configuration of the levels, rooms and puzzles by himself/herself. | This feature allows a player to feel like a developer of the game and reveal creativity. It creates an additional level of depth to the game, thus making the gameplay experience more enjoyable. |

### Quality requirements
Author: Ece Doganer

| ID | Short name | Quality attribute | Description | Rationale | Alternatives |
|---|---|---|---|---|---|
| QR1 | Extensible World | Maintainability, Reusability | System shall be extensible in terms of levels, rooms, and objects. | Adaptability: code is less complex, less reliant on storyline, more adaptable to different stories. | A system designed for one unique story-line. |
| QR2 | Instantaneous results | Responsiveness, Reliability | System shall respond to any action player performs, within 1 second. If action is impossible, input is unclear, there should be a message. | Expected from software experience: instant results. Also, requirement signals response time to user, thus indicating error. | Long waiting times in game. Coding without speed in mind, resulting in loading messages. |
| QR3 | Ready for input | Availability | System shall show full story immediately, and be ever-ready for input. | Users have their own speed of reading. User’s desire for system's readiness for input is connected to desire for immediate output. | Story-based text shown in increments, helping readers read along the intentions/pacing of story. Our system shall show story-text immediately, signaling input-readiness when screen is printed. If user intends to move north 12 steps, there is no delay. |
| QR4 | Bonus: Help Orientate | Understandability | All rooms should have a clear name. The backtrack feature helps users orientate in text-based world. System should record visited locations, and through backtrack-button go to previously visited locations. The map of the level, shows previously visited, clickable rooms (teleporting). | Users can get lost in text-adventure games, or forget which room needed which item. Our aim is to make orientation easier. | Backtrack feature is a bad solution if user backtracks big amount of steps, and has to return to furthest room. Alternative is a graphical map of visited rooms. Human brains have limited memory space, thus it is more useful to see previous rooms a few steps back than all visited rooms combined (think big levels). Thus, our first priority is the backtrack feature, and then visual map. |
| QR5 | Bonus: Natural Language Parsing | Understandability, Usability | CLI input should function with natural language form. Input string should be segmented into words. Input is valid iff: input is a valid direction in current room, is an existing item in the room that needs to be "used", or are two existing items where one is in the inventory, and the other is an item in the room that cannot be picked up, and requires an item to solve a puzzle. | Game should be immersive and playable for any human mastering basic English (and typing skill). | 1. Console-like commands. Not user-friendly, and requires user to learn before playing. Game should be intuitive, should give cognitive space for storyline immersion. 2. QR6. |
| QR6 | Bonus: GUI | Understandability, Usability, Security | Through graphical user interface, player immediately, intuitively sees which actions at current location can be performed. (Movement buttons should highlight when movable. Inventory would be graphically represented by a table, with scroll-buttons indicating infinite item-space. If Hint-feature is on, items should be sorted to usability in current room, and highlighted if usable.) Use of GUI, enabling user to see which actions can be performed at present location, will lessen error messages received from basic actions (movement, inventory actions), permitting user to spend cognitive effort on the story. | Qualitative games are intuitive and immersive. GUI solves issues of CLI: 1. Cognitive overload of user through error messages received for basic actions. 2. Security of game: predefined buttons can only be clicked. If error arises, it is not due to misuse of CLI by user. 3. User orientation should be better than with words. 4. GUI  visually explains rules of game, while CLI does not. | Error messages from CLI solved by storyline jokes (not a technical, extensible solution). |

### Java libraries
Author: Mateusz Belka

| Name (with link) | Description |
|---|---|
| [Gradle](https://gradle.org) | Our project, as well as the majority of projects in Java, make extensive use of libraries and frameworks. Thus, it is necessary to have a method of dependency management to allow developers to focus on designing the software itself and not manage the tools. Gradle provides such support, and therefore we use it to simplify the process of using pre-existing tools to aid our sophisticated design. There are several reasons why we have decided to use Gradle. First of all, high performance - this means a decrease of built time and an optimization of the work: running only necessary tasks, processing files that have changed and reusing the build of outputs with the same inputs. Secondly, since we are working in the Intellij IDEA, it is crucial for us and our workflow that the tool would support the IDE we are working with. It affects not only productivity and convenience but also time spent on working on certain parts of the code. Finally, as we have mentioned, dependency management. Dependency is a library that is used by a developer in the source code. Gradle allows for resolving this dependency by locating declared dependencies for performing a specific task at runtime. This way, it prevents certain libraries from leaking into the user's classpath and provides better-modelled and faster builds. |
| [Text-IO](https://github.com/beryx/text-io) | Users interact with their computers in widely different manners. Therefore, a part of them has very limited knowledge of the capabilities of their operating system. As such in order not to force users into launching our game from terminal, which many users may be unfamiliar with, our goal is provide an executable file that can be launched by just clicking on it. In a default situation attempting to do that would result in nothing happening as console input and output calls would be ignored without terminal being present. However, our intention is for our game to open in custom third-party swing terminal in scenarios where the game is not already being launched through one. Such terminal would naturally integrate with java.io.Console calls. |
| [JOpt Simple](https://github.com/jopt-simple/jopt-simple) | Our aim is to allow users to communicate with our system using natural language form. In order to achieve this, the users' input has to be parsed. We intend to utilize this library to maintain high-quality readable input parsing code which executes highly complicated tasks behind the scene. |
| [Java.time](https://github.comMenoDataTime4J) | A time library provides API for time, duration, instants and other timestamps. For the implementation of certain bonus features, it is important to have a time library. Starvation is a part of a hunger point feature. Starvation is a process during which a character is not consuming any goods for a certain period of time. Time library provides all the necessary attributes for the implementation of a starvation functional feature.|
| [FXGL](https://almasb.github.io/FXGL/) | As part of bonus feature we aim to implement a GUI widget toolkit instead of CLI due to it's more user-friendly interface as well as additional graphical functionality which hopefully will allow the user to have more enjoyable interface experience. Additionally, GUI provides a more stable executable version of the software since it's independent of users terminal. On top of that, default terminals tend to frighten novice computer users. JavaFX is more preferential than similar libraries such as Lanterna due to more advanced and accessible documentation. Additionally, the proposed GUI libraries all provide the same functionality for our limited needs, and therefore it makes sense to select the one which is the most straightforward in implementation. The final version of GUI aims to represent a variation of terminal-based UI. |
