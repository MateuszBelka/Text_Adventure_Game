# Assignment 1
## Introduction
Author: Taylor Doughty

   In this course, Software Design, we are going to be designing a text-based adventure game coded with Java. We will be using GitHub in order to collaborate while writing code, which will be synched to IntelliJ. For this system, we will be implementing game features along with satisfying quality requirements. As a main idea for developing our system, we are focused on dividing implementation of the features from the game logic. In doing so, the features of the game can act as a “blueprint” for game developers to create a game of their own. Therefore, the users of this project will be not only players, but also game developers.
   
The main idea of our game, is that it will be a single-player text adventure game in which a player can navigate through a series of rooms. The player will have the ability to interact with their environment in order to progress through the game. We will implement interactable objects in a way in which game developers may change and apply their own game logic easily.

To give a more detailed look at the exact features of the game, they are the following: The first feature is rooms. How this works, is that independently of the story, the player will always belong to a room, as they are the overacting system of the adventure game. The second feature is movement. The player will be able to move freely between the rooms, assuming that the rooms are interconnected and the storyline of the game allows them to do so. Concerning features available during the start-up of the game, they are the following three: The third feature is the ability to create a new game. When the game is first started-up, the user will have the option to start a new game, which allows the user to begin the first game save or to restart. Next, the fourth feature is the ability to continue a saved game. When the game is started-up, the user will also have the option to continue a previously started game, this way, they can carry-on with progress. The fifth feature is the option to be a game creator. What this means exactly, is that at the start-up of the game, the user will be able to create a new story, along with determining room configuration and information concerning each room. As for the sixth feature, concerning items, players will be informed about the possible items present in the room they are currently in. They will also have the ability to pick up items and place them in their inventory. Concerning items, that leads to the seventh feature. The players will be able to store these items in their inventory, and use them in the room in which they are currently in. Regarding saving progress of the game, there are two functionalities. The first being our eighth feature, in which the player will have the option to save current progress tied to the story they are playing. This will allow them to resume the game from the same position and same necessary information necessary to continue the game.There is also the feature of automatic saving, which is out ninth feature. The system will automatically save the player’s progress, and therefore the player will have the ability to access their latest saved information by selecting “continue” at the start menu. The ninth feature of the game is HP (health points). This feature indicates the level of health of a character, which then determines the ability to function and perform certain tasks in the game. HP can be lost due to attacks or starvation, and it can be restored by consuming food. The current HP value will be displayed along with the maximum HP possible as a numerical value on the screen. We also have determined three bonus features that should be implemented into our game. These bonus features are combat, experience,  hunger, and a GUI function feature, meaning an interface with buttons that players will be able to press in order to perform certain movements, actions, and use items.

When thinking of the features and design of our project, we were influenced by the game Zork. Primarily, the idea is that the protagonist adventures and explores a world, in which they can interact with objects and the world around them. Because the project is to be a “minimal clone” of the game, we also designed the features of the gameplay taking inspiration from the game. As for the display/appearance of the game, we have taken inspiration from a tutorial. 




Inspiration:  
[Zork](https://en.wikipedia.org/wiki/Zork)  
[How to Make Text Adventure Game with GUI in Java](https://www.youtube.com/watch?v=G5yr4sekAI0)

## Features
Author: Valeriya Komarnitskaya, Mateusz Belka, Ece Doganer

<When defining both functional features and quality requirements, remember that you will need to come back to them in Assignments 2 and 3 and explicitly state how specific parts of models/implementation satisfy them.>

### Functional features

**Core Features** Note:(use "shall" instead of "should")

| ID  | Short name  | Description  |  Rationale |
|---|---|---|---|
| F1 | Room | Rooms are the overarching system in our variation of the text adventure game. Independently from the story, the player shall always belong to an individual room. Each story has its own room configuration which is a list of rooms which are connected in terms of how the player can move between them. | Rooms allow for a precise organization of fundamental part of any text adventure game which is exploration. Division of locations which the player can inhabit into rooms allows for clear communication between structural elements of the game logic. From gameplay perspective is allows user to get familiar with the core concepts of the game from which all other features branch out from. |
| F2 | Movement | The player shall have the choice to move freely between rooms as long as those rooms are interconnected and possible story-related requirements are met. | The progression of the story is crucial to our game as we believe it incentivizes user to continue playing. Ability to move between rooms gives the story creator the means to create a compelling and complex story that would otherwise not be achievable. |
| F3 | New Game | At the start of the game the user shall have the option to start a new game. That allows the user to begin the first game or restart his/her progress and begin anew. | providing a user-friendly interface to start a new game is crucial. It also allows the user to conveniently be able to restart the game if the player desires so. |
| F4 | Continue Game| At the start of the game the user shall have the option to continue previously started game. That allows the user to carry on with already achieved progress. | We aim to support complex and unique stories, and as such, they might not be completed during one session. Giving the user the ability to decide how long each session will create a positive user experience. |
| F5 | Items | The player shall be informed about the possible items present in the room he/she is currently in. The player shall have the option to pick up those items and place them in the inventory. | Puzzle-solving is crucial part o progression in adventure games, so our goal is to implement an item system that is intuitive and fun to use by players. |
| F6 | Inventory | The player shall have the option of picking up items, storing them in inventory and using them in the room that the player is currently in. | Puzzle-solving is a crucial part of progression in adventure games. As such, we want to provide users with high quality and intuitive inventory system that fully supports meaningful and challenging use of items to solve puzzles. |
| F7 | Explicit Save | The player shall have the option to save current progress tied to the story she/he is playing at the moment. That will include all necessary information needed to resume the game at a later point after the game executable is opened again. | The ability to have an explicit button for saving tends to give players a relaxing feeling. From our personal experience, we've noticed people generally tend to not trust automatic save systems and depend on their action of saving the game. |
| F8 | Automatic Save| The system shall automatically save the player's progress. The player shall automatically have access to the latest saved information by selecting "Continue" at the start menu. | Novice users tend to go to another extreme of never saving their progress and afterwards regret not saving. To avoid such issues, we decided to implement autosave feature as part of our quality of life improvements for users. |


**Bonus Features** Note:(instead of "shall" use "should")

| ID  | Short name  | Description  |  Rationale |
|---|---|---|---|
| F9 | Health Points/HP | Health points are indicating the level of health of a character and determine the ability to function and perform certain tasks in the game world. Health value can be lost due to attack by enemy or through starvation. Health can also be restored by consuming different kinds of food. Current health value shall be displayed during combat as well as every time a player changes rooms. | Including health points in a game is essential in order to implement additional features such as combat or hunger properly. We believe that these features together add a sense of danger, create exciting challenges for a player and makes a gameplay experience more enjoyable. |
| F10 | Hunger level | A numerical measurement that determines whether a character is starving or not. Fifty hunger points lead to health points reduction, while health point reduction may lead to death. The longer the character was without consuming food, the more hunger points will be gained. A hunger point reduction happens when a player feeds the character. Current hunger level against the maximum hunger level shall be visible to a player when a character switches rooms. | Hunger is an additional challenge for a player that will make a story more interesting and game experience more enjoyable. |
| F11 | Combat | A battle against an enemy until a player will die or defeat an opponent. After defeating an enemy, there is a chance of receiving items. Each combat has a risk of losing health. A player might be able to receive special weapons through items in rooms or as an award for defeating the enemy. The player will be able to use those weapons in combat in order to hit harder. Using weapon shall also influence time spent on defeating an enemy and increase the probability of a win.| Combat system presents another level of depth to our Text Adventure Game. It allows the player to have more unique challenges and progress in a different manner in comparison to default one, which is puzzle-solving. |
| F12 | Experience points/XP | Numerical measurement indicating the experience of the character. The character starts with zero experience at the beginning of the game. Through successful puzzle-solving and defeating enemies, a character gains points. Experience points' collection leads to a level upgrade. Experience points shall be visible to a player on the screen at the end of combat, whenever they are increased and after entering another room. | Implementing experience points in our game is essential in order to include an additional feature such as a level upgrade. This way, a player will have a larger motivation to be active in the game in order to gain experience and upgrade a level. |
| F13 | Levelling | The level is a numerical value that indicates the level you are at in the game. At the beginning of the game, a player has a zero level. Through successful puzzle-solving and defeating enemies, a character gains experience points. After getting a certain amount of points, it shall be possible to level up. Different levels require a different number of experience points in order to level up. Level of a player shall be visible on the screen after entering a room, at the end of the combat and after the level upgrade. | Adding levelling feature will create additional challenges to a player and will motivate him/her to get more points and to level up in the game. The feature will make our Text Adventure Game more interesting and attractive to a player. |
| F14 | Graphical User Interface | In our implementation, Graphical User Interface is a variation of a terminal-based User Interface. The goal of our GUI is to present in user-friendly and intuitive manner features like inventory and movement directions buttons. At the start of the game, the inventory should be presented as a set of empty slots. The slot will be filled after the character will pick up an item. The slot will become empty after using an item. When it comes to movement, there should be four clickable buttons pointing to North, East, South and West. They should be presented on the screen at all times. | The Graphical User Interface feature aims to make a game experience more straightforward and enjoyable for a player. The GUI shall be implemented in order to increase user-friendliness, simplify the process of learning for a player and decrease the chance of making an input mistake by a player. |

### Quality requirements
Author: Ece Doğaner

Reasoning followed for the quality requirements is mostly grounded on user-friendly interaction through terminal, basic system expectancy for a good gaming experience, all while considering the extendability of the game. More detailed reasoning per quality requirement is given in the 'Rationale' section.

| ID | Short name | Quality attribute | Description | Rationale | Alternatives |
|---|---|---|---|---|---|
| QR1 | Natural Language Progressing (NLP) | Understandability, Usability | Input on the command line shall function with natural language form as much as possible. | Game should be immersive and playable for any human mastering basic English and some typing skill. | 1. Console-like commands. Not user-friendly, and requires user to learn before playing. Game should be intuitive, and should immediately give cognitive space for storyline immersion. 2. See bonus QR6: GUI |
| QR2 | Extensible World | Maintainability, Reusability | The game shall be easily extensible in terms of levels, rooms, and objects. | As we are making a sort of game backbone tool to fit different stories, this requirement focuses on adaptability in general, makes game code less complex and less reliant on storyline, and more adaptable to different stories. | Alternatives: A system designed for one unique story-line. Or a not fully extensible system. |
| QR3  | Instantaneous results | Responsiveness, Reliability | The game shall respond to any action the player performs, within 1 second. If action is not possible, input is not understood, or there is some delay in our 1 second responsiveness rule (ex. big amount of items to check through), there will be a message. | This feature is expected from any software experience: instant results. Secondly, this requirement signals that user can expect the game to respond. This signaling could be beneficial in case there is a big crash or grand error. | Alternatives: User would not like loading messages, while game has crashed. |
| QR4 | Ready for input | Availability | Game shall show full story immediately, and be ever-ready for input. | Users have their own speed of reading. User desire for system's readiness for input is connected to desire for immediate output. | Alternatives: Some games prefer story-based text to be shown in increments, helping readers read along the intentions and pacing of the story. Our game will show all information immediately. In this way, we signal that input is possible when loading screen is possible. If user intends to move north 12 steps, there won't be a delay like waiting for printing story text to terminal. |
| QR5 | Help user orientate | Understandability | All rooms will have a clear name. The backtrack feature helps users orientate in text-based world. Game shall record visited locations, and through backtrack-button go to previously visited locations. A bonus feature we might implement is a map of the level, which shows previously visited rooms, which are click-able (a sort of teleport function). | Reasoning is that users can easily get lost in rooms full of text, or forget which room needed which item. Our aim is to make orientation in text-based games, easier. | This backtrack feature would be a bad solution if the user needs to backtrack a big amount of steps, and then return to furthest room. Or backtracking through teleporting (bonus map feature) might be confusing. Alternative is a visual map of visited rooms. For our game to be truly extensible(think big amount of rooms), it is more useful to see previous rooms of a few steps back than all the visited rooms combined. Thus, our priority is the backtrack feature, and then a visual map of the level feature. |
|QR6| BONUS : GUI | Understandability, Usability, Security | Through a graphical user interface, player can immediately and intuitively see which actions at the current place can be performed. (Movement buttons can be highlighted when they are able to be performed. Inventory would be visually represented by a table, with buttons to indicate its infiniteness and scrollability. If the bonus hint feature is toggled on, items will be sorted to usability in the current room, and highlighted if they can be used.) The use of a GUI, enabling user to see which actions can be performed at present time, will nullify error messages received from basic actions (movement, inventory actions), permitting user to spend their effort on the story. | A qualitative game is intuitive and immersive. GUI solves issues of CLI: Firstly, cognitive overload of user through error messages received for basic actions. Secondly, security of game: predefined buttons can only be clicked. We provide visual clue of buttons that work at current room. If an error arises, it is not due to misuse of CLI by user. Thirdly, user orientation should be better than with words. And finally, GUI visually explains how to play the game. CLI would need to explain rules for playing. | Alternatives: CLI : error messages telling the user what isn't possible, resulting in possible frustration and bad gaming experience. There are games that solve this by storyline jokes or one-liner jokes on what the user is intending to do. But that would be a story-line based solution per action taken, not a technical, extensible solution. |

Word Count: 817

### Java libraries
Author: Mateusz Belka

| Name (with link) | Description  |
|---|---|
| [Gradle](https://gradle.org/) | Our project, as well as the majority of projects in Java, make extensive use of libraries and frameworks. Thus, it is necessary to have a method of dependency management to allow developers to focus on designing the software itself and not manage the tools. Gradle provides such support, and therefore we use it to simplify the process of using pre-existing tools to aid our sophisticated design. |
| [Text-IO](https://github.com/beryx/text-io) | Users interact with their computers in widely different manners. Therefore, a part of them has very limited knowledge of the capabilities of their operating system. As such in order not to force users into launching our game from terminal, which many users may be unfamiliar with, our goal is provide an executable file that can be launched by just clicking on it. In a default situation attempting to do that would result in nothing happening as console input and output calls would be ignored without terminal being present. However, our intention is for our game to open in custom third-party swing terminal in scenarios where the game is not already being launched through one. Such terminal would naturally integrate with java.io.Console calls. |
| [JOpt Simple](https://jopt-simple.github.io/jopt-simple/) | Our aim is to allow users to communicate with our system using natural language form. In order to achieve this the users input has to be parsed. We intend to utilize this library to maintain high quality readable input parsing code which executes highly complicated tasks behind the scene. |
| [JDSL](https://cs.brown.edu/cgc/jdsl/) | Due to the nature of our project, specific data structures will be necessary to maintain information about the state of the game comprehensively and transparently. It is possible to have such an outcome only in a scenario where proper data structures are utilized. As such, we will be making use of java library specifically created to provide an extensive choice of data structures we can tailor specifically to our needs. |
| [Time4J](https://github.com/MenoData/Time4J) | Time management will be necessary as part of the hunger system. This management will be aided by Time4J library. |
| [FXGL](https://almasb.github.io/FXGL/) | As part of bonus feature we aim to implement a GUI widget toolkit instead of CLI due to it's more user-friendly interface as well as additional graphical functionality which hopefully will allow the user to have more enjoyable interface experience. Additionally, GUI provides a more stable executable version of software since it's independent of users terminal. On top of that default terminals tend to frighten novice computer users. JavaFX is more preferential than similar libraries such as Lanterna due to more advanced and accessible documentation. Additionally, the proposed GUI libraries all provide the same functionality for our limited needs, and therefore it makes sense to select the one which is the most straightforward in implementation. The final version of GUI aims to represent a variation of terminal-based UI. |