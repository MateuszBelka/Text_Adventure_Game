# Assignment 1
Maximum number of words for this document: 2500
## Introduction
Author: Taylor Doughty

&emsp; We are designing a text-based adventure game. We will be implementing game features along with satisfying quality requirements. We have focused on dividing implementation of the features from the game logic. In doing so, the features of the game can act as a “blueprint” for game developers to create a game of their own. What this means, is that the game features are created separate from the storyline, therefore allowing game creators to input their own game logic.

&emsp; Our game is a single-playerStats text adventure game. The playerStats will have the ability to interact with their environment by moving rooms, picking up items to place in an inventory, using these items on static items, or interacting with static items alone. When these actions are successfully completed, the playerStats will gain puzzle points which results in upgrading their level. Once the max number of levels has been achieved, the playerStats wins the game! 

&emsp; To give a more detailed look at the exact features, they are the following: First feature is rooms (F1). How this works, is that the playerStats will always belong to a room, as they are the overacting system of the adventure game. Players will be able to move to and from rooms depending on which directions are available (north, south, east, and west). Next is  movement (F2). The playerStats will be able to move between the rooms, assuming that the rooms are interconnected and the storyline of the game allows them to do so. Concerning features available during the start-up of the game, they are the following three: The ability to create a new game (F3). When the game is first started-up, the user will have the option to start a new game, which allows the user to begin the first game save or to restart. Next is the ability to continue a saved game (F4). When the game is started-up, the user will also have the option to continue a previously started game, this way, they can carry-on with progress. We also have the implementation of items (F5), in which players will be informed about the items present in the room they are currently in. There are two types of items: pickupable items, and static items. The former have the ability to be picked up, put in an inventory, and used on the latter. Static items are also able to be actioned on their own. Finally, there are inventories (F6). The players will be able to store pickupable items in their inventory, and use them on static items in the room in which they are currently in. 

&emsp; There are also bonus features of the game that should be implemented. The first is HP, or health points (F7). This indicates the level of health of a character, which then determines the ability to function and perform tasks in the game, such as movement between rooms, and actioning items. HP can be lost due to attacks or starvation, and it can be restored by consuming food. The current HP value will be displayed during combat and every time a playerStats changes rooms. This feature will allow the implementation of combat or hunger in a way that adds a sense of danger and risk within the game, therefore making the gameplay more entertaining. There is also combat (F8), in which a playerStats will be able to battle an enemy until the playerStats dies or the enemy is defeated. Along with this feature, players may have the ability to receive special weapons that can increase the probability of winning and the decrease that of losing.Next is experience points/XP (F9), which will be a numerical measure that indicates the experience of the character gained by successfully completing puzzle-solving elements of the game, and defeating enemies in combat. Next, levelling (F10) is a bonus feature of this game. To elaborate, players will be able to increase their “Level,” and this is done by completing puzzles and gaining puzzle points. These puzzle points are achieved by successfully actioning items. Once x amount of puzzles are completed, players will increase their level by one. In order for the playerStats to win the game, they must complete all levels of the game.  Next comes hunger (F11) in which is a numerical measurement that indicates the character’s level of hunger. If fifty hunger points are reached, then it will result in a health point reduction. If the playerStats reaches a certain number of health points, it may result in death and termination of the save file. Hunger points are reduced by consuming food. This feature coincides with the feature of HP, and will add dynamism to the game. Our next feature concerns puzzles (F12), in which game creators will be able to have as many puzzles as they would like per room. Next: winning and losing (F13). The idea is that in game creator mode, the creator can choose the amount of levels necessary to win the game. A playerStats can lose by reaching a certain level of health, in which they must restart from either the beginning or the last save point. Players will have the ability to input commands to complete actions as well (F14). The final bonus features, F15 and F16, involve saving the game. The former is explicit saving, in which players can save at any moment. The latter is automatic saving, in which the system automatically saves progress.

&emsp; For this project, we were influenced by the game Zork, in that the protagonist adventures and explores a world in which they can interact with objects and the world around them. Because the project is to be a “minimal clone” of the game, we also designed the features of the gameplay taking inspiration from the game. As for the display/appearance of the game, we have taken inspiration from a tutorial. 


Inspiration:

[Zork](https://en.wikipedia.org/wiki/Zork)

[How to Make Text Adventure Game with GUI in Java](https://www.youtube.com/watch?v=G5yr4sekAI0)

***WORD COUNT: 965/1000***

## Features
Authors: Ece Doganer, Valeriya Komarnitskaya, Mateusz Belka

### Functional features


| ID  | Short name  | Description  |
|---|---|---|
| F1 | Instructions | User can interact with the interactive story through typing instructions. These instructions have the following possible syntax:<br/><br/> core:<br/>`[command]`<br/> `[command] + [direction]`<br/>  `[command] + [item]`<br/><br/>bonus:<br/>  `[command] + [npc]`<br/> `[command] + [item] + [item]`<br/> `[command] + [item] + [npc]`<br/><br/> Available item, npc, and direction instructions, depend on the story.<br/><br/>  All possible instructions for `[direction]` are as follows:<br/> `north, east, south, west, northeast, northwest, southeast, southwest`.<br><br> Available `[commands]` are as follows:<br> core:<br>`save, load, pickup, move, use`<br> bonus:<br> `quit, talk, drop, give, consume, open, close, push, pull, unlock, attack, break, cut, examine, look, directions, inventory, help, read, listen, smell, back, menu`<br><br> Bonus syntax and their functionality are as follows: <br>`[item]` ---> If possible, picks up item if it is in player's current location, or, consumes item if it is in player's inventory <br> `[npc]` ---> If possible, talks with npc<br> `[direction]` ---> If possible, moves to the location in this direction<br/><br/> The functionality of the commands will be hardcoded. In order to make the game customizable, instructions (excluding save, load, quit, menu, help, back, drop, inventory, directions) will print interaction text. This instruction text is customizable for a game creator.<br/><br/> The validity of an instruction, depends on the story, and the current location of the player. If an instruction is invalid, an error message will be shown (see instruction validation). <br>--- |
| F2 | Puzzles | ---<br>In order to win the game, a player interacts with the interactive story, playing through the story from start till end. In this story, there might be one or more levels, with each their own amount of puzzles. A puzzle is ambiguously described here. Interaction with an item can or can't give puzzle points, depending on the type of interaction, and the intention of the game creator with this item. <br><br>The interactions containing instructions with the commands 'use', 'give', 'open', 'close', 'push', 'pull', 'cut', could solve puzzles. The validity of these interactions, depends on the story (see Instructions). If the instruction is valid, performing these interactions will award a puzzle point. <br><br>The amount of the puzzle points per level, depends on the interactive story, and will be given by the game creator. After this amount of puzzles is complete, player can progress to the next level, or will receive a message indicating player has won the game. <br><br>Additionally: These puzzle points will not be known to the player, and the rationale here is to immerse player in the story instead of focusing on a score. <br>--- |
| F3 | Levels | ---<br>Each interactive story has one or many levels. Each level has its own amount of puzzle points, which require from the player to perform interactions. After every instruction, a check is run to see if the amount of puzzle points required to finish a level, has been reached. After performing the amount of interactions required, the system will teleport the player to the next level and its starting location.<br><br> Levels have a starting point for the player, a location. Levels have one or multiple locations. When entering a level, a description of the level is printed. These levels, will never be known to the player, in order to immerse in the story. <br><br>Game creators could see levels as a big event within the storyline, where a big part of the story can be described. <br>--- |
| F4 | Locations | ---<br>Levels have one or many locations. Locations can have items and npcs (see Items, NPCs). <br><br> If we would represent locations as nodes in a graph, the tree graph would have vertices with a maximum of 8 connected edges (north, east, south, west, northeast, northwest, southeast, southwest). Two vertices would be connected by exactly one path.<br><br> At the creation phase of a story, these locations will be connected with each other. These locations will be accessible for the player to move to them, at any time, as long as there is a connection from player's current location to the desired location. Core: moving will commence through `move [direction]` instruction. The direction, for example, north, will lead to the location saved for this direction, for the current location. <br><br> Each location will be unique, and will have a description and unique name. Every time a player visits a new location, its description will be printed automatically. When the player instructs `look`, the description of the location shall be printed (again), as well as a list of the names of items and npcs within this location. <br>--- |
| F5 | Items | ---<br>For every interactive story, there will be a number of items. Some of these items are necessary to win the game. There is no cap on the maximum amount of items. The minimum is at least one item, in order to have an interactive story with only one puzzle.<br><br> Items have characteristics, which will be checked, in order to do certain instruction combinations. For example:<br> if apple is a consumable, it will be possible to instruct 'consume apple' without an error message. Instructing it will print the interaction text of consuming this apple, on the screen. <br><br>The core list of traits of an item are that it can or can't be picked up, and used. <br><br>The full list of traits of an item, are as follows :<br> an item can or can't be consumed, used, used on another item, be used for another item, used on an npc, attacked, talked to, listened to, smelled, opened, closed, examined, pushed, pulled, cut, be used to cut with, be unlocked, be used to unlock with, be used to open with, be used to close with, be used as an item to open another item with, be pulled, be pushed, be read, be picked up, be broken, be used to break another item with, be used to cut an npc with, be dropped, be consumed,  ...  <br><br> When player is in a location with an item, the instruction `examine [item]` can be issued. The description of this item is then printed. The same instruction can also be issued for items in player's inventory. <br>--- | 
| F6 | Inventory | ---<br>A core feature is to have an inventory. The player will have the option of picking up items, storing them in inventory and using them in the location that the player is currently in. At any point, player should be able to instruct 'inventory', which gives an overview of the currently held items, if any. <br>--- |
| F7 | Bonus: NPCs | ---<br>For every interactive story, there might exist some Non-Playable Characters. The minimum is zero, the maximum is not capped. They are unique, with unique names, and should have unique descriptions and interaction possibilities. All NPC related functionality of the system, is bonus. <br><br>An important distinction is that there are two types of NPCs: friendly, and enemy.<br><br> Enemy NPCs do not have traits. When a location that the user enters contains an enemy NPC, a battle sequence will immediately commence. Player will need to battle this NPC. See feature Combat. <br><br> A friendly NPC has a list of traits   ..... (doing this and that to npc, if possible to do so, will grant puzzle points.)  <br><br> When the player is in a location with a friendly npc, `examine [npc]` can be instructed. This will print the description of the npc. <br>--- |
| F8 | Bonus: Combat Mode | ---<br> When there is an enemy NPC in the location that player enters, a battle sequence starts. In this primitive battle sequence, player can only attack the enemy, and be attacked. Player always attacks first, and deals damage to the enemy in the amount of strength points the player has, lowering enemy's health points. Just like player, Enemy also has deals damage the amount of his strength points, to the health points of player. Within this course, we do not plan on explanding the available commands in combat mode. <br><br>This battle commences until player defeats the opponent, or dies trying. In both cases, the battle sequence comes to an end. <br><br>When player dies, the only options left to do are to start a new story, load a previously saved story, or to quit game completely.<br><br>When player is victorious, first of all, the combat mode is over and the story can continue. So a battle can be described as an obstacle for the continuation of the story. Secondly, winning a battle increases the attack points and experience points of the player. This helps in the way that a player will be able to survive battle with more difficult foes later on. <br>--- |
| F9 | Bonus: Health Points | ---<br> Health points is a number which indicates health of the player. The total and current amount of health is customizable by the game creator. <br><br> Health can be lost due to attack by an enemy NPC or through starvation (when hunger level reaches zero). Health can be restored by consuming food (see Hunger feature). The amount of health restored by consuming an item, is customizable by the game creator. Default health points added per consumption is 10.<br><br> If the player has zero health points, the game is over. In this case, a new story can be started, a previously saved story can be loaded, or the game can be quit.<br><br> When player levels up, the total of health points will be increased, as well as the current health points. <br><br>Health is a bonus feature, that will be implemented only after finishing GUI feature. Thus, indication of health will be visual, through a bar that is updated when health increases or decreases. <br>---|
| F10 | Bonus: Strength Points | ---<br>In combat mode, the damage done is the number of strength points a player has. This number is customizable by the game creator. Enemy also has customizable strength points. Both inflict the amount of their strength points, to each others health points, sequentially. If an enemy is too strong for the player to handle, player can only tell by entering combat. In this case, player needs to load story from his last saved slot or from the autosave slot. Player can then hopefully avoid this location, thus avoiding the battle. Other battles can be started, to that player's strength improves. Or, player needs to find a way to solve the story without entering the battle. This is up to the game creator. <br>---  |
| F10 | Bonus: Experience Points and Player Level | ---<br>  <br>--- |
| F11 | Bonus: Hunger | ---<br> Hunger is a number that determines whether a character is starving or not. Fifty hunger points lead to health points reduction. The longer the character was without consuming food, the more hunger points are gained. A hunger point reduction happens when a playerStats feeds the character. <br>--- |
| F9 | Input Validation | ---<br>Input will be checked for validity, which we do in two steps: input- and instruction validity.<br><br>All input issued will print text. The distinction here is input and instruction: Input will firstly be parsed into 'words'. These words will be checked for validity. A word is valid if one of the next terms apply: - the word is equal to one of the commands in the command list. - the word is equal to one of the directions in the directions list. - the player's current location's npc list has an npc with the name, equal to the word. - the player's current location's item list has an item with the name, equal to the word. Or, the inventory's item list has an item with the name, equal to the word. When these terms apply, an input is valid. From here on, instruction validation can commence. If these terms do not apply, an error message will be given, stating that the system did not understand the input. Additional: The reason why input is checked immediately within inventory or current location of the player, is because it is faster. The alternative, checking through all existing items within a game, is time consuming and unnecessary. <br><br> After input is validated, instructions will be validated as follows: items and npcs have certain traits. For example, item apple can be picked up, and eaten. Depending on these traits, certain commands become valid: 'pickup apple' and 'eat apple'. Other commands, like 'cut apple', are invalid, and will result in an error message stating this item cannot be cut. If a valid instruction is given, the action will be performed. Indication of this action having been performed, is that a customizable interaction text will be printed. <br><br> After input and instruction are validated, the instruction will be handled. The instructions containing 'use, give, open, close, push, pull, cut', will give a puzzle point. Other instructions help player progress the story, help battle, or help still player's hunger. <br><br> All valid instructions will print an interaction text, which is customizable by the game creator. Certain instructions change the stats of the player.(see Hunger, EXP) ... <br>--- |
| F10 | Explicit Save Game | ---<br>Player shall have the option to save current progress tied to the story she/he is playing at the moment. This includes all necessary information needed to resume the game at a later point after the game executable is opened again. <br>--- |
| F11 | Load Game | ---<br>Player shall have the option to load a previously saved game. <br>--- |
| F12 | Bonus: Automatic Save Game | ---<br>After five inputs, irrespectively of their validity, the story will be saved in a special save slot, called Auto Save. Player can load the game from this slot. Additionally, auto-save feature is not available in combat-mode. <br>--- |
| F14 | Bonus: Game Creator Mode | ---<br>Bonus<br>--- |
| F15 | Bonus: Graphical User Interface | ---<br>Bonus<br>--- |
| F13 |  Movement | ---<br>Player has the choice to move between locations that are interconnected. this can be done by issuing `move [direction] `, or simply `[direction]`. Bonus syntax is that `move` can be exchanged by `run, go, walk`. <br>---|
|| Picking up Items ||
|| Using Items ||
|| -So many instructions.- ||

The following part I leave here to read and double check later on. You can ignore it for now. -Ece <br><br>
| F11 | Experience points/XP | Numerical measurement indicating the experience. The character starts with zero experience at the beginning of the game. Through successful puzzle-solving and defeating enemies, a character gains points. Experience points' collection leads to a level upgrade. | Implementing experience points in our game is essential in order to include an additional feature such as a level upgrade. This way, a playerStats has a larger motivation to be active in the game upgrade the level. | 
| F12 | Levelling | The level is a numerical value indicating the level you are at. After getting a certain amount of experience points, it shall be possible to level up. | Adding levelling feature creates additional challenges and motivates a playerStats to level up in the game. The feature makes our TAG more interesting and attractive to a playerStats. | 
| F13 | Hunger level | A numerical measurement that determines whether a character is starving or not. Fifty hunger points lead to health points reduction. The longer the character was without consuming food, the more hunger points are gained. A hunger point reduction happens when a playerStats feeds the character. | Hunger is an additional challenge for a playerStats that makes the game experience more enjoyable.| 
| F14 | Structure of puzzles | Puzzle-solving is one of the main challenges in our game world. The main aim of a character is to solve every single puzzle in each room. We plan on having one puzzle per room; however, in the game creator mode, a playerStats can choose as many puzzles as he/she wants per room. Puzzle in our game consists of picking up an item, finding the object to use the item on and using this item on. For example, if we see in the list of items key and the door, then to complete a puzzle, we need to use the key on the door. | Puzzle is an element of the game that makes a gameplay experience more enjoyable and the game interesting. A playerStats has a larger motivation to keep playing to solve as many puzzles as possible.  |
| F15 | Winning and losing the game | In our implementation, a playerStats wins a game when he/she solves all puzzles on each possible level. In the game creator mode, a playerStats has an opportunity to create as many puzzles, rooms and levels as he/she wants. Thus, it can make the average winning time longer or shorter, depending on the number of puzzles. A playerStats can lose a game by losing health. In this case, a playerStats is offered to either start the game from the beginning or from the last saved point. | The ability to win or lose the game creates an additional level of depth in the gaming experience. It makes a playerStats more motivated in playing and exploring the game. |
| F16 | Explicit Save | The playerStats shall have the option to save current progress tied to the story she/he is playing at the moment. That includes all necessary information needed to resume the game at a later point after the game executable is opened again. | The ability to have an explicit button for saving tends to give players a relaxing feeling. From our personal experience, we've noticed people generally tend to not trust automatic save systems and depend on their action of saving the game. |
| F17 | Automatic Save| The system shall automatically save the playerStats's progress. The playerStats shall automatically have access to the latest saved information by selecting "Continue" at the start menu. | Novice users tend to go to another extreme of never saving their progress and afterwards regret not saving. To avoid such issues, we decided to implement autosave feature as part of our quality of life improvements for users. |
| F18 | Game Creator mode | A feature when a playerStats can choose a configuration of the levels, rooms and puzzles by himself/herself. | This feature allows a playerStats to feel like a developer of the game and reveal creativity. It creates an additional level of depth to the game, thus making the gameplay experience more enjoyable. |

### Quality requirements
Author: Ece Doganer

| ID | Short name | Quality attribute | Description | Rationale | Alternatives |
|---|---|---|---|---|---|
| QR1 | Extensible World | Maintainability, Reusability | System shall be extensible in terms of levels, rooms, and objects. | Adaptability: code is less complex, less reliant on storyline, more adaptable to different stories. | A system designed for one unique story-line. |
| QR2 | Instantaneous results | Responsiveness, Reliability | System shall respond to any action playerStats performs, within 1 second. | Expected from software experience: instant results. Also, requirement signals response time to user, thus indicating error. | Long waiting times in game. Coding without speed in mind, resulting in loading messages. |
| QR3 | Ready for input | Availability | System shall show full story when a game has entered, and every time an input is issued. | Users have their own speed of reading. User’s desire for system's readiness for input is connected to desire for immediate output. | Story-based text shown in increments, helping readers read along the intentions/pacing of story. Our system shall show story-text immediately, signaling input-readiness when screen is printed. If user intends to move north 12 steps, there is no delay. |
| QR4 | Bonus: Help Orientate | Understandability | All rooms should have a clear name. The backtrack feature helps users orientate in text-based world. System should record visited locations, and through backtrack-button go to previously visited locations. The map of the level, shows previously visited, clickable rooms (teleporting). | Users can get lost in text-adventure games, or forget which room needed which item. Our aim is to make orientation easier. | Backtrack feature is a bad solution if user backtracks big amount of steps, and has to return to furthest room. Alternative is a graphical map of visited rooms. Human brains have limited memory space, thus it is more useful to see previous rooms a few steps back than all visited rooms combined (think big levels). Thus, our first priority is the backtrack feature, and then visual map. |
| QR5 | Bonus: Natural Language Parsing | Understandability, Usability | CLI input should function with natural language form. Input string should be segmented into words. Input is valid iff: input is a valid direction in current room, is an existing item in the room that needs to be "used", or are two existing items where one is in the inventory, and the other is an item in the room that cannot be picked up, and requires an item to solve a puzzle. In this way, user can write "please go north" and also "north". "In fridge, maybe try to put milk", awa "milk fridge". This is what is meant with NLP: it will only use trigger words: direction, pickupable item, or static item. | Game should be immersive and playable for any human mastering basic English (and typing skill). | 1. Console-like commands. Not user-friendly, and requires user to learn before playing. Game should be intuitive, should give cognitive space for storyline immersion. 2. QR6. |
| QR6 | Bonus: GUI | Understandability, Usability, Security | Through graphical user interface, playerStats immediately, intuitively sees which actions at current location can be performed. (Movement buttons should highlight when movable. Inventory would be graphically represented by a table, with scroll-buttons indicating infinite item-space. If Hint-feature is on, items should be sorted to usability in current room, and highlighted if usable.) Use of GUI, enabling user to see which actions can be performed at present location, will lessen error messages received from basic actions (movement, inventory actions), permitting user to spend cognitive effort on the story. | Qualitative games are intuitive and immersive. GUI solves issues of CLI: 1. Cognitive overload of user through error messages received for basic actions. 2. Security of game: predefined buttons can only be clicked. If error arises, it is not due to misuse of CLI by user. 3. User orientation should be better than with words. 4. GUI  visually explains rules of game, while CLI does not. | Error messages from CLI solved by storyline jokes (not a technical, extensible solution). |
| QR7 | input correctness | Understandability, usability | If action is incorrect, user should understand. This can be in form of a message, or another signal, like showing a red border with GUI. |||
| QR8 | input latency | Input will be issued within 1 second. |||
* Addition to QR6: We would display a map, where rooms will be clickable. Current room of playerStats will be changed per click.
* Addition to Backtracking: As we should track the movement of the playerStats, simply inputting "back" would change playerStats's current room into the previous visited room. When playerStats has "teleported" through use of map, the 'back' input simply would teleport back to the previously visited room.
* Addition to QR6: Our CLI can be connected to the buttons described earlier. Clickable "items" in the "inventory" can become a method that uses our CLI functionality. (eg. clicking milk and fridge would issue this as input in CLI.)

### Java libraries
Author: Mateusz Belka

| Name (with link) | Description |
|---|---|
| [Gradle](https://gradle.org) | Our project, as well as the majority of projects in Java, make extensive use of libraries and frameworks. Thus, it is necessary to have a method of dependency management to allow developers to focus on designing the software itself and not manage the tools. Gradle provides such support, and therefore we use it to simplify the process of using pre-existing tools to aid our sophisticated design. There are several reasons why we have decided to use Gradle. First of all, high performance - this means a decrease of built time and an optimization of the work: running only necessary tasks, processing files that have changed and reusing the build of outputs with the same inputs. Secondly, since we are working in the Intellij IDEA, it is crucial for us and our workflow that the tool would support the IDE we are working with. It affects not only productivity and convenience but also time spent on working on certain parts of the code. Finally, as we have mentioned, dependency management. Dependency is a library that is used by a developer in the source code. Gradle allows for resolving this dependency by locating declared dependencies for performing a specific task at runtime. This way, it prevents certain libraries from leaking into the user's classpath and provides better-modelled and faster builds. |
| [Text-IO](https://github.com/beryx/text-io) | Users interact with their computers in widely different manners. Therefore, a part of them has very limited knowledge of the capabilities of their operating system. As such in order not to force users into launching our game from terminal, which many users may be unfamiliar with, our goal is provide an executable file that can be launched by just clicking on it. In a default situation attempting to do that would result in nothing happening as console input and output calls would be ignored without terminal being present. However, our intention is for our game to open in custom third-party swing terminal in scenarios where the game is not already being launched through one. Such terminal would naturally integrate with java.io.Console calls. |
| [JOpt Simple](https://github.com/jopt-simple/jopt-simple) | Our aim is to allow users to communicate with our system using natural language form. In order to achieve this, the users' input has to be parsed. We intend to utilize this library to maintain high-quality readable input parsing code which executes highly complicated tasks behind the scene. |
| [Java.time](https://github.comMenoDataTime4J) | A time library provides API for time, duration, instants and other timestamps. For the implementation of certain bonus features, it is important to have a time library. Starvation is a part of a hunger point feature. Starvation is a process during which a character is not consuming any goods for a certain period of time. Time library provides all the necessary attributes for the implementation of a starvation functional feature.|
| [FXGL](https://almasb.github.io/FXGL/) | As part of bonus feature we aim to implement a GUI widget toolkit instead of CLI due to it's more user-friendly interface as well as additional graphical functionality which hopefully will allow the user to have more enjoyable interface experience. Additionally, GUI provides a more stable executable version of the software since it's independent of users terminal. On top of that, default terminals tend to frighten novice computer users.a JavaFX is more preferential than similar libraries such as Lanterna due to more advanced and accessible documentation. Additionally, the proposed GUI libraries all provide the same functionality for our limited needs, and therefore it makes sense to select the one which is the most straightforward in implementation. The final version of GUI aims to represent a variation of terminal-based UI. |
