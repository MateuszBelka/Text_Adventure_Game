# Assignment 1
Maximum number of words for this document: 2500
## Introduction
Author: Taylor Doughty

&emsp; We are designing a text-based adventure game. We will be implementing game features along with satisfying quality requirements. We have focused on dividing implementation of the features from the game logic. In doing so, the features of the game can act as a “blueprint” for game developers to create a game of their own. What this means, is that the game features are created separate from the storyline, therefore allowing game creators to input their own game logic.

&emsp; Our game is a single-playerStats text adventure game. The playerStats will have the ability to interact with their environment by moving rooms, picking up items to place in an inventory, using these items on static items, or interacting with static items alone. When these actions are successfully completed, the playerStats will gain puzzle points which results in upgrading their level. Once the max number of levels has been achieved, the playerStats wins the game! 

&emsp; To give a more detailed look at the exact features, they are the following: First feature is rooms (F1). How this works, is that the playerStats will always belong to a room, as they are the overacting system of the adventure game. Players will be able to move to and from rooms depending on which directions are available (north, south, east, and west). Next is  movement (F2). The playerStats will be able to move between the rooms, assuming that the rooms are interconnected and the storyline of the game allows them to do so. Concerning features available during the start-up of the game, they are the following three: The ability to create a new game (F3). When the game is first started-up, the user will have the option to start a new game, which allows the user to begin the first game save or to restart. Next is the ability to continue a saved game (F4). When the game is started-up, the user will also have the option to continue a previously started game, this way, they can carry-on with progress. We also have the implementation of items (F5), in which players will be informed about the items present in the room they are currently in. There are two types of items: pickupable items, and static items. The former have the ability to be picked up, put in an inventory, and used on the latter. Static items are also able to be actioned on their own. Finally, there are inventories (F6). The players will be able to store pickupable items in their inventory, and use them on static items in the room in which they are currently in. 

&emsp; There are also bonus features of the game that should be implemented. The first is HP, or health points (F7). This indicates the level of health of a character, which then determines the ability to function and perform tasks in the game, such as movement between rooms, and actioning items. HP can be lost due to attacks or starvation, and it can be restored by consuming food. The current HP value will be displayed during combat and every time a playerStats changes rooms. This feature will allow the implementation of combat or hunger in a way that adds a sense of danger and risk within the game, therefore making the gameplay more entertaining. There is also combat (F8), in which a playerStats will be able to battle an enemy until the playerStats dies or the enemy is defeated. Along with this feature, players may have the ability to receive special weapons that can increase the probability of winning and the decrease that of losing.Next is experience points/XP (F9), which will be a numerical measure that indicates the experience of the character gained by successfully completing puzzle-solving elements of the game, and defeating enemies in combat. Next, levelling (F10) is a bonus feature of this game. To elaborate, players will be able to increase their “Level,” and this is done by completing puzzles and gaining puzzle points. These puzzle points are achieved by successfully actioning items. Once x amount of puzzles are completed, players will increase their level by one. In order for the playerStats to win the game, they must complete all levels of the game.  Next comes hunger (F11) in which is a numerical measurement that indicates the character’s level of hunger. If fifty hunger points are reached, then it will result in a health point reduction. If the playerStats reaches a certain number of health points, it may result in death and termination of the save file. Hunger points are reduced by consuming food. This feature coincides with the feature of HP, and will add dynamism to the game. Our next feature concerns puzzles (F12), in which game creators will be able to have as many puzzles as they would like per room. Next: winning and losing (F13). The idea is that in game creator mode, the creator can choose the amount of levels necessary to win the game. A playerStats can lose by reaching a certain level of health, in which they must restart from either the beginning or the last save point. Players will have the ability to input commands to complete actions as well (F14). The final bonus features, F15 and F16, involve saving the game. The former is explicit saving, in which players can save at any moment. The latter is automatic saving, in which the system automatically saves progress.

&emsp; For this project, we were influenced by the game Zork, in that the protagonist adventures and explores a world in which they can interact with objects and the world around them. Because the project is to be a “minimal clone” of the game, we also designed the features of the gameplay taking inspiration from the game. As for the display/appearance of the game, we have taken inspiration from a tutorial. 


Inspiration:

[Zork](https://en.wikipedia.org/wiki/Zork)

[How to Make Text Adventure Game with GUI in Java](https://www.youtube.com/watch?v=G5yr4sekAI0)

***WORD COUNT: 965/1000***

## Features
Authors: Ece Doganer

### Functional features


| ID  | Short name  | Description  |
|---|---|---|
| F1 | Instructions | User can interact with the interactive story through typing instructions. These instructions have the following possible syntax:<br/><br/> core:<br/>`[command]`<br/> `[command] + [direction]`<br/>  `[command] + [item]`<br/><br/>bonus:<br/>  `[command] + [NPC]`<br/> `[command] + [item] + [item]`<br/> `[command] + [item] + [NPC]`<br/><br/> Available item, NPC, and direction instructions, depend on the story.<br/><br/>  All possible instructions for `[direction]` are as follows:<br/> `north, east, south, west, northeast, northwest, southeast, southwest`.<br><br> Available `[commands]` are as follows:<br> core:<br>`save, load, pickup, move, use`<br> bonus:<br> `quit, talk, drop, give, consume, open, close, push, pull, unlock, attack, break, cut, examine, look, directions, inventory, help, read, listen, smell, back, menu`<br><br> Bonus syntax and their functionality are as follows: <br>`[item]` ---> If possible, picks up item if it is in player's current location, or, consumes item if it is in player's inventory <br> `[NPC]` ---> If possible, talks with NPC<br> `[direction]` ---> If possible, moves to the location in this direction<br/><br/> The functionality of the commands will be hardcoded. In order to make the game customizable, instructions (excluding save, load, quit, menu, help, back, drop, inventory, directions) will print interaction text. This instruction text is customizable for a game creator.<br/><br/> The validity of an instruction, depends on the story, and the current location of the player. If an instruction is invalid, an error message will be shown (see instruction validation). <br>--- |
| F2 | Puzzles | ---<br>In order to win the game, a player interacts with the interactive story, playing through the story from start till end. In this story, there might be one or more levels, with each their own amount of puzzles. A puzzle is ambiguously described here. Interaction with an item can or can't give puzzle points, depending on the type of interaction, and the intention of the game creator with this item. <br><br>The interactions containing instructions with the commands 'use', 'give', 'open', 'close', 'push', 'pull', 'cut', could solve puzzles. The validity of these interactions, depends on the story (see Instructions). If the instruction is valid, performing these interactions will award a puzzle point. <br><br>The amount of the puzzle points per level, depends on the interactive story, and will be given by the game creator. After this amount of puzzles is complete, player can progress to the next level, or will receive a message indicating player has won the game. <br><br>Additionally: These puzzle points will not be known to the player, and the rationale here is to immerse player in the story instead of focusing on a score. <br>--- |
| F3 | Levels | ---<br>Each interactive story has one or many levels. Each level has its own amount of puzzle points, which require from the player to perform interactions. After every instruction, a check is run to see if the amount of puzzle points required to finish a level, has been reached. After performing the amount of interactions required, the system will teleport the player to the next level and its starting location.<br><br> Levels have a starting point for the player, a location. Levels have one or multiple locations. When entering a level, a description of the level is printed. These levels, will never be known to the player, in order to immerse in the story. <br><br>Game creators could see levels as a big event within the storyline, where a big part of the story can be described. <br>--- |
| F4 | Locations | ---<br>Levels have one or many locations. Locations can have items and NPCs (see Items, NPCs). <br><br> If we would represent locations as nodes in a graph, the tree graph would have vertices with a maximum of 8 connected edges (north, east, south, west, northeast, northwest, southeast, southwest). Two vertices would be connected by exactly one path.<br><br> At the creation phase of a story, these locations will be connected with each other. These locations will be accessible for the player to move to them, at any time, as long as there is a connection from player's current location to the desired location. Core: moving will commence through `move [direction]` instruction. The direction, for example, north, will lead to the location saved for this direction, for the current location. <br><br> Each location will be unique, and will have a description and unique name. Every time a player visits a new location, its description will be printed automatically. When the player instructs `look`, the description of the location shall be printed (again), as well as a list of the names of items and NPCs within this location. <br>--- |
| F5 | Items | ---<br>For every interactive story, there will be a number of items. Some of these items are necessary to win the game. There is no cap on the maximum amount of items. The minimum is at least one item, in order to have an interactive story with only one puzzle.<br><br> Items have characteristics, which will be checked, in order to do certain instruction combinations. For example:<br> if apple is a consumable, it will be possible to instruct 'consume apple' without an error message. Instructing it will print the interaction text of consuming this apple, on the screen. <br><br>The core list of traits of an item are that it can or can't be picked up, and used. <br><br>The full list of traits of an item are extensive, and will be treated in other features. <br><br> When player is in a location with an item, the instruction `examine [item]` can be issued. The description of this item is then printed. The same instruction can also be issued for items in player's inventory. <br>--- | 
| F6 | Inventory | ---<br>A core feature is for the player to have an inventory. The player will have the option of picking up items, storing them in inventory and using them in the location that the player is currently in. The inventory can hold an indefinite amount of items. A bonus is to be able to instruct `inventory`, which gives an overview of the currently held items, if any. <br>--- |
| F7 | Bonus: NPCs | ---<br>For every interactive story, there might exist some Non-Playable Characters. The minimum is zero, the maximum is not capped. They are unique, with unique names, and should have unique descriptions and interaction possibilities. All NPC related functionality of the system, is bonus. <br><br>An important distinction is that there are two types of NPCs: friendly, and enemy.<br><br> Enemy NPCs do not have traits. When a location that the user enters contains an enemy NPC, a battle sequence will immediately commence. Player will need to battle this NPC. See feature Combat. <br><br> A friendly NPC has a list of traits, which can be set to true and false. These traits, which we further discuss in other features, will enable certain interactions with this NPC.<br><br> When the player is in a location with a friendly NPC, `examine [NPC]` can be instructed. This will print the description of the NPC. <br>--- |
| F8 | Bonus: Combat Mode | ---<br> When there is an enemy NPC in the location that player enters, a battle sequence starts. In this primitive battle sequence, player can only attack the enemy, and be attacked. Player always attacks first, and deals damage to the enemy in the amount of strength points the player has, lowering enemy's health points. Just like player, enemy also has deals damage the amount of his strength points, to the health points of player. Within this course, we do not plan on expanding the available commands in combat mode. <br><br>This battle continues until player defeats the opponent, or dies trying. In both cases, the battle sequence comes to an end. <br><br>When player dies, the only options left to do are to start a new story, load a previously saved story, or to quit game completely.<br><br>When player is victorious, first of all, the combat mode is over and the story can continue. So a battle can be described as an obstacle for the continuation of the story. Secondly, winning a battle increases the attack points and experience points of the player. This helps in the way that a player will be able to survive battle with more difficult foes later on. <br>--- |
| F9 | Bonus: Health Points | ---<br> Health points is a number which indicates health of the player. The total and current amount of health is customizable by the game creator. <br><br> Health can be lost due to attack by an enemy NPC or through starvation (when hunger level reaches zero). When hunger is at a customizable amount which we term 'starvation mode', a customizable amount of health points will be deduced from the total health points. Health can be restored by consuming food (see Hunger feature). The amount of health restored by consuming an item, is customizable by the game creator. Default health points added per consumption is 10.<br><br> If the player has zero health points, the game is over. In this case, a new story can be started, a previously saved story can be loaded, or the game can be quit.<br><br> When player levels up, the total of health points will be increased, as well as the current health points. <br><br>Health is a bonus feature, that will be implemented only after finishing GUI feature. Thus, indication of health will be visual, through a bar that is updated when health increases or decreases. <br>---|
| F10 | Bonus: Strength Points | ---<br>In combat mode, the damage done is the number of strength points a player has. This number is customizable by the game creator. Enemy also has customizable strength points. Both inflict the amount of their strength points, to each others health points, sequentially. If an enemy is too strong for the player to handle, player can only tell by entering combat. In this case, player needs to load story from his last saved slot or from the auto-save slot. Player can then hopefully avoid this location, thus avoiding the battle. Other battles can be started, to that player's strength improves. Or, player needs to find a way to solve the story without entering the battle. This is up to the game creator. <br>---  |
| F11 | Bonus: Experience Points and Player Level | ---<br> Issuing a fully valid instruction for certain instructions, will grant the player experience points. Also through battle, player can be rewarded experience points. With a total amount of experience points, which is customizable for the game creator, the player will level up. Through leveling up, strength points will be gained, in order to battle tougher enemies. <br>--- |
| F12 | Bonus: Hunger | ---<br> Hunger is a number that determines whether a character is starving or not. The default is that at fifty hunger points, a customizable amount of health points will be reduced. <br>--- |
| F13 | Input Validation | ---<br>Input will be checked for validity, which we do in two steps: input- and instruction validity.<br><br>All input issued will print text. The distinction here is input and instruction: Input will firstly be parsed into 'words'. These words will be checked for validity. A word is valid if one of the next terms apply: - the word is equal to one of the commands in the command list. - the word is equal to one of the directions in the directions list. - the player's current location's NPC list has an NPC with the name, equal to the word. - the player's current location's item list has an item with the name, equal to the word. Or, the inventory's item list has an item with the name, equal to the word. When these terms apply, an input is valid. From here on, instruction validation can commence. If these terms do not apply, an error message will be given, stating that the system did not understand the input. Additional: The reason why input is checked immediately within inventory or current location of the player, is because it is faster. The alternative, checking through all existing items within a game, is time consuming and unnecessary. <br><br> After input is validated, instructions will be validated as follows: items and NPCs have certain traits. For example, item apple can be picked up, and eaten. Depending on these traits, certain commands become valid: 'pickup apple' and 'consume apple'. Other commands, like 'cut apple', are invalid, and will result in an error message stating this item cannot be cut. If a valid instruction is given, the action will be performed. Indication of this action having been performed, is that a customizable interaction text will be printed. <br><br> After input and instruction are validated, the instruction will be handled. The instructions containing 'use, give, open, close, push, pull, cut', will give a puzzle point. Other instructions help player progress the story, help battle, or help still player's hunger. <br><br> All valid instructions will print an interaction text, which is customizable by the game creator. Certain instructions change the stats of the player.(see Hunger, EXP) ... <br>--- |
| F14 | Explicit Save Game | ---<br>Player shall have the option to save current progress tied to the story she/he is playing at the moment. This includes all necessary information needed to resume the game at a later point after the game executable is opened again. To explicitly save, player needs to be outside of the combat mode, and has to issue `save`. <br>--- |
| F15 | Load Game | ---<br>Player shall have the option to load a previously saved game. Player can only load outside of combat mode. When issuing `load`, player will be presented with the previously saved files that he can select. There is also an option to go back without loading.<br>--- |
| F16 | Bonus: Automatic Save Game | ---<br>After five inputs, irrespectively of their validity, the story will be saved in a special save slot, called Auto Save. Player can load the game from this slot. Additionally, auto-save feature is not available in combat-mode. <br>--- |
| F17 | Bonus: Game Creator Mode | ---<br>This is a very big bonus feature. The user of our game, will be able to create a story: user will be able to create levels with names and descriptions and amount of puzzle points, locations with names and descriptions with their own sets of connecting locations, items, friendly and enemy NPCs. Those entities will have a name, description, and will have a set of traits, resulting in the instructions available with that entity. All these instructions will require an interaction text as well, for when the user has issued them. We will have a questionnaire for the game creator, which will ask all this information sequentially. Error messages will be shown if names contain spaces. Error messages will be shown for empty inputs. Game creator cannot quit the process of creating a game, and cannot make adjustments. Game creator will be prompted to write in top down motion, starting with one level, its locations, those locations' items and NPCs and their traits. Then, another level can be entered, or the game creator mode can be finished. This story will then be saved in one of the save slots available. <br>--- |
| F18 | Bonus: Graphical User Interface | ---<br>This bonus feature will have 4 major scenes:<br> Scene one is the welcoming scene, where player can click buttons to: start a new game, load a saved game, or quit.<br><br>The second scene is entered when player picks the new game button. In this scene, previously created games can be selected. If create game feature is implemented, it also be able to be selected, here. We have a button to go back.<br><br> A third scene, is when the player would have picked 'load game' instead of 'new game'. Here, we see three save slots, and one slot of auto-save. These slots will be used to indicate a saved game, which can be selected. <br><br>The final scene, is the adventure scene. Both selecting a new game, and loading a previously saved game, will lead to the adventure scene. In this scene, the player's health level, hunger level, and experience level, will be represented in bars with numbers inside them. Also, the level of the player will be represented in large, with a number. All these elements will be grouped together. Another elements in the GUI will be the text box, where printing story text and receiving errors will happen. Finally, GUI will contain a terminal element where input may be entered. <br>--- |
| F19 | Bonus: Backtracking | ---<br>Player's visited locations, is saved in a list. Every time Player instructs `back`, the player will be teleported to the previous location visited. If list is empty, meaning player has traced his steps back and returned to the starting position, then, when issuing `back` will give an error. <br>--- |
| F20 |  Movement | ---<br>Player can move between locations that are interconnected. this can be done by issuing `move [direction] `, or simply `[direction]`. Bonus syntax is that `move` can be exchanged by `run, go, walk`. <br>---|
| F21 | Picking up Items | ---<br> If there are items in the current location of the player, then the player can try to pick up those items. If the item player wishes to pick up has the trait that it can be picked up, then the item will be deleted from the list of the current location, and will be copied into the list of inventory. A customizable interaction text for this specific item will be printed, which game creator can use as indication of the instruction's success but also for the story progression. Also, the item's trait pickup-able will become false, and trait drop-able will become true. <br><br> Items can be picked up by issuing `pickup [item]`. Bonus syntax is to `pick [item]`, where 'up' will be ignored. Also, just `[item]` could be used. If item is in the current location of the player, and has the trait that it can be picked up, it will be picked up.<br>--- |
| F22 | Bonus: Dropping Items | An item will have the drop-able trait after it is picked up. We can then, drop this item. If item has the trait that it is break-able, then it will break when dropping. <br>---   |
| F23 | Bonus: Examining Items and NPCs | If an item or NPC is in the current location of the player, the player can examine it, through issuing `examine [item]` or `examine [NPC]`. This instruction will print the description of the item or NPC. Also items in the inventory can be examined. Examining can happen as often as the player would like to. |
| F24 | Bonus: Look around in the Location |---<br> When player issues `look`, a description should be printed of the current location. Next to this, the items and NPCs in this location will be listed by their name.  <br>---|
| F25 | Bonus: Consume Items or NPCs |---<br> Items or NPCs can have the trait that they can be consumed. When issuing `consume [item]` or `consume [npc]`, player can consume said entity for health and hunger points. The default health points gained is 10, and the default for hunger is 15. The game creator can customize this. Bonus syntax is `eat` and `drink`, though the issue that for example an apple can be drank, we will not solve. Interaction text will be printed.  <br>---|
| F26 | Bonus: Smell location, item, npc|---<br> Issuing `smell` will smell player's current location. For `smell [item]`: if item has the trait that it can be smelled, then it will become valid to issue, and will result in the printing of the interaction for smelling, of said item. For `smell [npc]`, the same applies. <br>---|
| F27 | Bonus: Listen to location, item, npc |---<br>Exactly the same as smell instruction, applies to the `listen`, `listen [item]` and `listen [npc]` instructions. Interaction text will be printed. <br>---|
| F28 | Bonus: Talk to item, npc |---<br>The same as the smell instruction but excluding location, applies to talking: `talk to [item]` and `talk to [npc]`. Interaction text will be printed. <br>---|
| F29 | Bonus: Push item, npc |---<br>The same as the talk instruction applies to pushing: `push [item]` and `push [npc]`. By issuing this instruction, player receives puzzle points and experience points. Interaction text will be printed.  <br>---|
| F30 | Bonus: Pull to item, npc |---<br>Exactly same as the push instruction applies to pulling: `pull [item]` and `pull [npc]`. Also, puzzle points and experience points are awarded for pulling. Interaction text will be printed.  <br>---|
| F31 | Bonus: Open item, npc |---<br>Exactly same as the pull instruction applies to opening: `open [item]` and `open [npc]`. Also, puzzle points and experience points are awarded for opening. Additionally, some items need other items to open, just like npcs. `open [item] with [item]` or `open [npc] with [item]` is applicable here. Interaction text will be printed. <br>---|
| F32 | Bonus: Close item, npc |---<br>Exactly same as the pull instruction applies to closing: `close [item]` and `close [npc]`. Also, puzzle points and experience points are awarded for closing. Interaction text will be printed. <br>---|
| F33 | Bonus: Read item |---<br> If item in current location or in inventory, has the trait that it is readable, then `read [item]` instruction will be valid. When issuing it, the interaction text for reading this item, will be printed.<br>---|
| F34 | Bonus: Quit Game |---<br>At any time except in combat mode, player can issue `quit`. The game will stop expecting input, and finish running, closing the window. An additional bonus word for this is `exit`. This feature will not save or check if player really wanted to quit. <br>---|
| F35 | Bonus: Help |---<br> At any time except in combat mode, player can issue `help`. This will print a list of all the possible syntax combinations. <br>---|
| F36 | Bonus: GUI menu instruction |---<br> At any time except in combat mode, player can issue `menu`. This will change the adventure scene into the welcome scene. There will be no back button. <br>---|
| F37 | Bonus: Attack item, NPC |---<br> At any time except in combat mode, player can try to issue `attack [item]` or `attack [npc]` for the items and npcs player's current location. If these items and npcs's have the trait that they can be attacked, then attacking can commence. If an item is attacked, its interaction description for attacking is printed. Furthermore, if item has the trait that it can be broken, then item will break. If NPC is attacked, a battle sequence will commence. See Combat feature. <br>---|
| F38 | Bonus: Unlock item |---<br>At any time except in combat mode, player can try to issue `unlock [item] with [item]`. If item1 will have the trait that it can be unlocked, and will have item2 saved as its unlocking item, then item1 will be unlocked. Puzzle points are given for unlocking. Also interaction text will be printed. <br>---|
| F39 | Bonus: <br>Use item,<br> Use item on item,<br> Use item on NPC |---<br> If an item has the trait that it can be used, then `use [item]` can be issued. If item1 has the trait that it can be used on item2, and item2 has item1 as the item it requires to be used by then `use [item] on [item]` is valid. If NPC requires item to be used on it, then `use [item] on [npc]` is valid. Using instructions grant puzzle points.   <br>---|
| F40 | Bonus: Break item |---<br> An item with the breaking trait, can be broken. This item might be able to be broken as is, or might require another item to break it: `break [item]`, and `break [item] with [item]`, respectively. For the latter, item to break needs to have the the item to help break, as its required item. Breaking an item prints interaction text, increases puzzle points and experience points, and also removes the item from inventory or current location of the player. <br>---|
| F41 | Bonus:<br>Cut item with item,<br> Cut NPC with item |---<br> If an item or npc has the trait that it can be cut, then they require a certain item to be cut with. if this is the right item in the instructions `cut [item] with [item]`, and `cut [npc] with [item]`, then these instructions are valid, and will print interaction text. Cutting gives puzzle points and experience.  <br>---|
| F42 | Bonus: Give item to NPC |---<br> If NPC has the trait that it requires an item, and requires the item in the issued instruction of `give [item] to [npc]`, then this instruction is valid, and will print the interaction text for giving, for this item. Also, puzzle points and experience will be given.<br>---|
| F43 | Bonus: Get directions |---<br>At any time except in combat mode, player can issue `directions`. A list of directions available to move to, from the current location, will be printed. <br>---|

### Quality requirements
Author: Ece Doganer

| ID | Short name | Quality attribute | Description | Rationale | Alternatives |
|---|---|---|---|---|---|
| QR1 | Extensible World | Maintainability, Reusability | System shall be extensible in terms of levels, rooms, and objects. | Adaptability: code is less complex, less reliant on storyline, more adaptable to different stories. | A system designed for one unique story-line. |
| QR2 | Instantaneous results | Responsiveness, Reliability | System shall respond to any action playerStats performs, within 1 second. | Expected from software experience: instant results. Also, requirement signals response time to user, thus indicating error. | Long waiting times in game. Coding without speed in mind, resulting in loading messages. |
| QR3 | Ready for input | Availability | System shall show full story when a game has entered, and every time an input is issued. | Users have their own speed of reading. User’s desire for system's readiness for input is connected to desire for immediate output. | Story-based text shown in increments, helping readers read along the intentions/pacing of story. Our system shall show story-text immediately, signaling input-readiness when screen is printed. If user intends to move north 12 steps, there is no delay. |
| QR7 | input correctness | Understandability, usability | If action is incorrect, user should understand. This can be in form of a message, or another signal, like showing a red border with GUI. |||
| QR8 | input latency | Input will be issued within 1 second. |||


### Java libraries
Author: Mateusz Belka

| Name (with link) | Description |
|---|---|
| [Gradle](https://gradle.org) | Our project, as well as the majority of projects in Java, make extensive use of libraries and frameworks. Thus, it is necessary to have a method of dependency management to allow developers to focus on designing the software itself and not manage the tools. Gradle provides such support, and therefore we use it to simplify the process of using pre-existing tools to aid our sophisticated design. There are several reasons why we have decided to use Gradle. First of all, high performance - this means a decrease of built time and an optimization of the work: running only necessary tasks, processing files that have changed and reusing the build of outputs with the same inputs. Secondly, since we are working in the Intellij IDEA, it is crucial for us and our workflow that the tool would support the IDE we are working with. It affects not only productivity and convenience but also time spent on working on certain parts of the code. Finally, as we have mentioned, dependency management. Dependency is a library that is used by a developer in the source code. Gradle allows for resolving this dependency by locating declared dependencies for performing a specific task at runtime. This way, it prevents certain libraries from leaking into the user's classpath and provides better-modelled and faster builds. |
| [Text-IO](https://github.com/beryx/text-io) | Users interact with their computers in widely different manners. Therefore, a part of them has very limited knowledge of the capabilities of their operating system. As such in order not to force users into launching our game from terminal, which many users may be unfamiliar with, our goal is provide an executable file that can be launched by just clicking on it. In a default situation attempting to do that would result in nothing happening as console input and output calls would be ignored without terminal being present. However, our intention is for our game to open in custom third-party swing terminal in scenarios where the game is not already being launched through one. Such terminal would naturally integrate with java.io.Console calls. |
| [JOpt Simple](https://github.com/jopt-simple/jopt-simple) | Our aim is to allow users to communicate with our system using natural language form. In order to achieve this, the users' input has to be parsed. We intend to utilize this library to maintain high-quality readable input parsing code which executes highly complicated tasks behind the scene. |
| [Java.time](https://github.comMenoDataTime4J) | A time library provides API for time, duration, instants and other timestamps. For the implementation of certain bonus features, it is important to have a time library. Starvation is a part of a hunger point feature. Starvation is a process during which a character is not consuming any goods for a certain period of time. Time library provides all the necessary attributes for the implementation of a starvation functional feature.|
| [FXGL](https://almasb.github.io/FXGL/) | As part of bonus feature we aim to implement a GUI widget toolkit instead of CLI due to it's more user-friendly interface as well as additional graphical functionality which hopefully will allow the user to have more enjoyable interface experience. Additionally, GUI provides a more stable executable version of the software since it's independent of users terminal. On top of that, default terminals tend to frighten novice computer users.a JavaFX is more preferential than similar libraries such as Lanterna due to more advanced and accessible documentation. Additionally, the proposed GUI libraries all provide the same functionality for our limited needs, and therefore it makes sense to select the one which is the most straightforward in implementation. The final version of GUI aims to represent a variation of terminal-based UI. |
